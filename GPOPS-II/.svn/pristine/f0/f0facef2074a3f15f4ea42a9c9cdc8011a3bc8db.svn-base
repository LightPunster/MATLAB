function [setup, probinfo, NumDefaults, DefaultStr, NumConflicts, ConflictsStr, NumWarnings, WarningsStr] = gpopsVerifySetup(usersetup)
% gpopsVerifySetup
% This function checks the user setup for errors

% get default settings
defaults = gpopsDefaults;

% initiate NumDefaults, NumConflicts, NumWarnings
NumDefaults = 0;
NumConflicts = 0;
NumWarnings = 0;

DefaultStr = cell(0);
ConflictsStr = cell(0);
WarningsStr = cell(0);

if ~isstruct(usersetup);
  error('GPOPS-II ERROR: setup must be a structure');
end

% check usersetup for field 'name'
if isfield(usersetup,'name');
  % check if usersetup.name is a string
  if ischar(usersetup.name);
    setup.name = usersetup.name;
  else
    % error if usersetup.name is not a character string
    error('GPOPS-II ERROR: setup.name must be a character string');
  end
  % remove field 'name'
  usersetup = rmfield(usersetup,'name');
else
  % error name is not provided
  error(['GPOPS-II ERROR: setup structure requires the problem name '...
    'be provided in the field setup.name']);
end

% check usersetup for field 'displaylevel'
if isfield(usersetup,'displaylevel');
  % check if usersetup.displaylevel is numeric
  if ~isempty(usersetup.displaylevel);
    if isnumeric(usersetup.displaylevel);
      if size(usersetup.displaylevel,1) ~= 1 || size(usersetup.displaylevel,2) ~= 1;
        % error usersetup.displaylevel is not a scalar
        error('GPOPS-II ERROR: setup.displaylevel must be a scalar value');
      end
      if usersetup.displaylevel == 0 || usersetup.displaylevel == 1 || usersetup.displaylevel == 2;
        setup.displaylevel = usersetup.displaylevel;
      else
        % error if usersetup.displaylevel is not 0, 1, 2
        error('GPOPS-II ERROR: setup.displaylevel must be 0, 1, or 2');
      end
    else
      % error if usersetup.displaylevel is not a numeric string
      error('GPOPS-II ERROR: setup.displaylevel must be 0, 1, or 2');
    end
  else
    % set default setup.displaylevel
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.displaylevel = ',num2str(defaults.displaylevel)]);
    setup.displaylevel = defaults.displaylevel;
  end
  % remove field 'displaylevel'
  usersetup = rmfield(usersetup,'displaylevel');
else
  % set default setup.displaylevel
  NumDefaults = NumDefaults + 1;
  DefaultStr{NumDefaults} = (['    Using default setting setup.displaylevel = ',num2str(defaults.displaylevel)]);
  setup.displaylevel = defaults.displaylevel;
end

% check usersetup for field 'method'
if isfield(usersetup,'method');
  % check if usersetup.method is a string
  if ~isempty(usersetup.method);
    if ischar(usersetup.method);
      if strcmpi(usersetup.method, 'RPM-differentiation') || strcmpi(usersetup.method, 'RPM-integration');
        setup.method = usersetup.method;
      else
        % error not valid method
        error(['GPOPS-II ERROR: Invalid option for setup.method, valid '...
          'options are ''RPM-Differentiation'' or ''RPM-Integration''']);
      end
    else
      % error usersetup.name is not a character string
      error('GPOPS-II ERROR: setup.method must be a character string');
    end
  else
    % set default setup.method
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.method = ''',defaults.method,'''']);
    setup.method = defaults.method;
  end
  % remove field 'method'
  usersetup = rmfield(usersetup,'method');
else
  % set default setup.method
  NumDefaults = NumDefaults + 1;
  DefaultStr{NumDefaults} = (['    Using default setting setup.method = ''',defaults.method,'''']);
  setup.method = defaults.method;
end

% check usersetup for field 'nlp'
if isfield(usersetup,'nlp');
  % check usersetup.nlp for field 'solver'
  if ~isempty(usersetup.nlp);
    if ~isstruct(usersetup.nlp);
      error('GPOPS-II ERROR: setup.nlp must be a structure');
    end
    if isfield(usersetup.nlp,'solver');
      if ~isempty(usersetup.nlp.solver);
        if ischar(usersetup.nlp.solver);
          if strcmpi(usersetup.nlp.solver, 'ipopt') || strcmpi(usersetup.nlp.solver, 'snopt');
            setup.nlp.solver = usersetup.nlp.solver;
          else
            % error not valid nlp.solver
            error(['GPOPS-II ERROR: Invalid option for setup.nlp.solver, valid '...
              'options are ''ipopt'' and ''snopt''']);
          end
        else
          % error usersetup.nlp.solver is not a character string
          error('GPOPS-II ERROR: setup.nlp.solver must be a character string');
        end
      else
        % set default setup.nlp.solver
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.solver = ''',defaults.nlp.solver,'''']);
        setup.nlp.solver = defaults.nlp.solver;
      end
      % remove field 'nlp.solver'
      usersetup.nlp = rmfield(usersetup.nlp,'solver');
    else
      % set default setup.nlp.solver
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.solver = ''',defaults.nlp.solver,'''']);
      setup.nlp.solver = defaults.nlp.solver;
    end
    
    % nlp options are only set for the nlp being used
    if strcmpi(setup.nlp.solver, 'ipopt');
      % check if nlp.snoptoptions is a field
      if isfield(usersetup.nlp,'snoptoptions');
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.nlp.snoptoptions because '...
          'setup.nlp.solver = ''',setup.nlp.solver,'''']);
        usersetup.nlp = rmfield(usersetup.nlp,'snoptoptions');
      end
      
      % check usersetup.nlp for field 'ipoptoptions'
      if isfield(usersetup.nlp,'ipoptoptions');
        if ~isempty(usersetup.nlp.ipoptoptions);
          if ~isstruct(usersetup.nlp.ipoptoptions);
            error('GPOPS-II ERROR: setup.nlp.ipoptoptions must be a structure');
          end
          if isfield(usersetup.nlp.ipoptoptions,'linear_solver');
            if ~isempty(usersetup.nlp.ipoptoptions.linear_solver);
              if ischar(usersetup.nlp.ipoptoptions.linear_solver);
                if strcmpi(usersetup.nlp.ipoptoptions.linear_solver, 'mumps') || strcmpi(usersetup.nlp.ipoptoptions.linear_solver, 'ma57');
                  setup.nlp.ipoptoptions.linear_solver = usersetup.nlp.ipoptoptions.linear_solver;
                else
                  % error not valid nlp.solver
                  error(['GPOPS-II ERROR: Invalid option for setup.nlp.ipoptoptions.linear_solver, valid '...
                    'options are ''mumps'' and ''ma57''']);
                end
              else
                % error usersetup.nlp.solver is not a character string
                error('GPOPS-II ERROR: setup.nlp.ipoptoptions.linear_solver must be a character string');
              end
            else
              % set default for ipoptoptions.linear_solver
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.linear_solver = ''',defaults.nlp.ipoptoptions.linear_solver,'''']);
              setup.nlp.ipoptoptions.linear_solver = defaults.nlp.ipoptoptions.linear_solver;
            end
            % remove field 'usersetup.nlp.ipoptoptions.linear_solver'
            usersetup.nlp.ipoptoptions = rmfield(usersetup.nlp.ipoptoptions,'linear_solver');
          else
            % set default for ipoptoptions.linear_solver
            NumDefaults = NumDefaults + 1;
            DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.linear_solver = ''',defaults.nlp.ipoptoptions.linear_solver,'''']);
            setup.nlp.ipoptoptions.linear_solver = defaults.nlp.ipoptoptions.linear_solver;
          end
          
          if isfield(usersetup.nlp.ipoptoptions,'tolerance');
            if ~isempty(usersetup.nlp.ipoptoptions.tolerance);
              if isnumeric(usersetup.nlp.ipoptoptions.tolerance);
                if size(usersetup.nlp.ipoptoptions.tolerance,1) ~= 1 || size(usersetup.nlp.ipoptoptions.tolerance,2) ~= 1;
                  % error usersetup.nlp.ipoptoptions.tolerance is not a scalar
                  error('GPOPS-II ERROR: setup.nlp.ipoptoptions.tolerance must be a scalar value');
                end
                if usersetup.nlp.ipoptoptions.tolerance <= 0;
                  % error usersetup.nlp.ipoptoptions.maxiterations is < 0
                  error('GPOPS-II ERROR: setup.nlp.ipoptoptions.tolerance must be greater than 0');
                end
                setup.nlp.ipoptoptions.tolerance = usersetup.nlp.ipoptoptions.tolerance;
              else
                % error usersetup.nlp.ipoptoptions.tolerance is not numeric
                error('GPOPS-II ERROR: setup.nlp.ipoptoptions.tolerance must be a numerical value');
              end
            else
              % set default for ipoptoptions.tolerance
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.tolerance = ',num2str(defaults.nlp.ipoptoptions.tolerance)]);
              setup.nlp.ipoptoptions.tolerance = defaults.nlp.ipoptoptions.tolerance;
            end
            % remove field 'usersetup.nlp.ipoptoptions.tolerance'
            usersetup.nlp.ipoptoptions = rmfield(usersetup.nlp.ipoptoptions,'tolerance');
          else
            % set default for ipoptoptions.tolerance
            NumDefaults = NumDefaults + 1;
            DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.tolerance = ',num2str(defaults.nlp.ipoptoptions.tolerance)]);
            setup.nlp.ipoptoptions.tolerance = defaults.nlp.ipoptoptions.tolerance;
          end
          
          if isfield(usersetup.nlp.ipoptoptions,'warmstart');
              if ~isempty(usersetup.nlp.ipoptoptions.warmstart);
                  if islogical(usersetup.nlp.ipoptoptions.warmstart) || isnumeric(usersetup.nlp.ipoptoptions.warmstart); %islogical, isnumeric
                     if size(usersetup.nlp.ipoptoptions.warmstart,1) ~= 1 || size(usersetup.nlp.ipoptoptions.warmstart,2) ~= 1;
                        % error usersetup.nlp.ipoptoptions.warmstart is not a scalar
                        error('GPOPS-II ERROR: setup.nlp.ipoptoptions.warmstart must be a single value');
                     end
                    if usersetup.nlp.ipoptoptions.warmstart ~= 0 && usersetup.nlp.ipoptoptions.warmstart~= 1
                       % error usersetup.nlp.ipoptoptions.warmStart is not
                       % a boolean value
                        error('GPOPS-II ERROR: setup.nlp.ipoptoptions.warmstart must be a numerical or logical value of 1 for true or 0 for false'); 
                    end
                    probinfo.warmStartFlag = usersetup.nlp.ipoptoptions.warmstart;
                  else
                        % error usersetup.nlp.ipoptoptions.warmstart is not numeric
                        error('GPOPS-II ERROR: setup.nlp.ipoptoptions.warmstart must be a numerical or logical value of 1 for true or 0 for false');   
                  end
              else    
                % set default for ipoptoptions.warmStart
                NumDefaults = NumDefaults + 1;
                DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmstart = ',num2str(defaults.nlp.ipoptoptions.warmstart)]);
                probinfo.warmStartFlag = defaults.nlp.ipoptoptions.warmstart;
              end
              % remove field 'usersetup.nlp.ipoptoptions.warmstart'
              usersetup.nlp.ipoptoptions = rmfield(usersetup.nlp.ipoptoptions,'warmstart');
          else
            % set default for ipoptoptions.warmstart
            NumDefaults = NumDefaults + 1;
            DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmstart = ',num2str(defaults.nlp.ipoptoptions.warmstart)]);
            probinfo.warmStartFlag = defaults.nlp.ipoptoptions.warmstart;
          end
          
          if isfield(usersetup.nlp.ipoptoptions,'warmstartmesh');
              if probinfo.warmStartFlag == 1
                  if ~isempty(usersetup.nlp.ipoptoptions.warmstartmesh);
                      if isnumeric(usersetup.nlp.ipoptoptions.warmstartmesh);
                         if size(usersetup.nlp.ipoptoptions.warmstartmesh,1) ~= 1 || size(usersetup.nlp.ipoptoptions.warmstartmesh,2) ~= 1;
                            % error usersetup.nlp.ipoptoptions.warmstartmesh is not a scalar
                            error('GPOPS-II ERROR: setup.nlp.ipoptoptions.warmstartmesh must be a single value');
                         end
                        if usersetup.nlp.ipoptoptions.warmstartmesh ~= 1 && usersetup.nlp.ipoptoptions.warmstartmesh ~= 2
                           % error usersetup.nlp.ipoptoptions.warmstartmesh is not
                           % 1st or 2nd
                            error('GPOPS-II ERROR: setup.nlp.ipoptoptions.warmstartmesh must be a value of 1 or 2'); 
                        end
                        probinfo.warmStartMesh = usersetup.nlp.ipoptoptions.warmstartmesh;
                        if probinfo.warmStartMesh > 1
                           probinfo.warmStartFlag = 0; 
                        end
                      else
                            % error usersetup.nlp.ipoptoptions.warmstartmesh is not numeric
                            error('GPOPS-II ERROR: setup.nlp.ipoptoptions.warmstartmesh must be a numerical value.');   
                      end
                  else    
                    % set default for ipoptoptions.warmstartmesh
                    NumDefaults = NumDefaults + 1;
                    DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmstartmesh = ',num2str(defaults.nlp.ipoptoptions.warmstartmesh)]);
                    probinfo.warmStartMesh = defaults.nlp.ipoptoptions.warmstartmesh;
                    if probinfo.warmStartMesh > 1
                       probinfo.warmStartFlag = 0; 
                    end
                  end
              else
                  NumWarnings = NumWarnings + 1;
                  WarningsStr{NumWarnings} = (['    Ignoring setup.nlp.ipoptoptions.warmstartmesh as warmstart is off']);
              end
              % remove field 'usersetup.nlp.ipoptoptions.warmstartmesh'
              usersetup.nlp.ipoptoptions = rmfield(usersetup.nlp.ipoptoptions,'warmstartmesh');
          else
            % set default for ipoptoptions.warmstartmesh
            if probinfo.warmStartFlag == 1
                NumDefaults = NumDefaults + 1;
                DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmstartmesh = ',num2str(defaults.nlp.ipoptoptions.warmstartmesh)]);
                probinfo.warmStartMesh = defaults.nlp.ipoptoptions.warmstartmesh;
                if probinfo.warmStartMesh > 1
                   probinfo.warmStartFlag = 0; 
                end
            end
          end              
          
          if isfield(usersetup.nlp.ipoptoptions,'maxiterations');
            if ~isempty(usersetup.nlp.ipoptoptions.maxiterations);
              if isnumeric(usersetup.nlp.ipoptoptions.maxiterations);
                if size(usersetup.nlp.ipoptoptions.maxiterations,1) ~= 1 || size(usersetup.nlp.ipoptoptions.maxiterations,2) ~= 1;
                  % error usersetup.nlp.ipoptoptions.maxiterations is not a
                  % scalar
                  error('GPOPS-II ERROR: setup.nlp.ipoptoptions.maxiterations must be a scalar value');
                end
                if ceil(usersetup.nlp.ipoptoptions.maxiterations) ~= floor(usersetup.nlp.ipoptoptions.maxiterations);
                  % error usersetup.nlp.ipoptoptions.maxiterations is not an
                  % integer
                  error('GPOPS-II ERROR: setup.nlp.ipoptoptions.maxiterations must be an integer value');
                end
                if usersetup.nlp.ipoptoptions.maxiterations <= 0;
                  % error usersetup.nlp.ipoptoptions.maxiterations is < 0
                  error('GPOPS-II ERROR: setup.nlp.ipoptoptions.maxiterations must be greater than 0');
                end
                setup.nlp.ipoptoptions.maxiterations = usersetup.nlp.ipoptoptions.maxiterations;
              else
                % error usersetup.nlp.ipoptoptions.maxiterations is not numeric
                error('GPOPS-II ERROR: setup.nlp.ipoptoptions.maxiterations must be a numerical value');
              end
            else
              % set default for ipoptoptions.maxiterations
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.maxiterations = ',num2str(defaults.nlp.ipoptoptions.maxiterations)]);
              setup.nlp.ipoptoptions.maxiterations = defaults.nlp.ipoptoptions.maxiterations;
            end
            % remove field 'usersetup.nlp.ipoptoptions.maxiterations'
            usersetup.nlp.ipoptoptions = rmfield(usersetup.nlp.ipoptoptions,'maxiterations');
          else
            % set default for ipoptoptions.maxiterations
            NumDefaults = NumDefaults + 1;
            DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.maxiterations = ',num2str(defaults.nlp.ipoptoptions.maxiterations)]);
            setup.nlp.ipoptoptions.maxiterations = defaults.nlp.ipoptoptions.maxiterations;
          end
          % check usersetup.nlp.ipoptoptions for unknown fields
          % valid fields are 'linear_solver', 'tolerance', 'maxiterations'
          URF = fieldnames(usersetup.nlp.ipoptoptions);
          for URFcount = 1:size(URF,1);
            NumWarnings = NumWarnings + 1;
            WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.nlp.ipoptoptions.',URF{URFcount}]);
          end
        else
          % set default for ipopt nlp options
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.linear_solver = ''',defaults.nlp.ipoptoptions.linear_solver,'''']);
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.tolerance = ',num2str(defaults.nlp.ipoptoptions.tolerance)]);
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.maxiterations = ',num2str(defaults.nlp.ipoptoptions.maxiterations)]);
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmstart = ',num2str(defaults.nlp.ipoptoptions.warmstart)]);
          setup.nlp.ipoptoptions = defaults.nlp.ipoptoptions;
          probinfo.warmStartFlag = defaults.nlp.ipoptoptions.warmstart;
          if probinfo.warmStartFlag == 0
              setup.nlp.ipoptoptions = rmfield(defaults.nlp.ipoptoptions,'warmstartmesh');
          elseif probinfo.warmStartFlag == 1
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmstartmesh = ',num2str(defaults.nlp.ipoptoptions.warmstartmesh)]);
              probinfo.warmStartMesh = defaults.nlp.ipoptoptions.warmstartmesh;
              if probinfo.warmStartMesh > 1
              probinfo.warmStartFlag = 0;
              end
          end
        end
        
        % remove field 'usersetup.nlp.ipoptoptions'
        usersetup.nlp = rmfield(usersetup.nlp,'ipoptoptions');
      else
        % set default for ipopt nlp options
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.linear_solver = ''',defaults.nlp.ipoptoptions.linear_solver,'''']);
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.tolerance = ',num2str(defaults.nlp.ipoptoptions.tolerance)]);
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.maxiterations = ',num2str(defaults.nlp.ipoptoptions.maxiterations)]);
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmstart = ',num2str(defaults.nlp.ipoptoptions.warmstart)]);
        setup.nlp.ipoptoptions = defaults.nlp.ipoptoptions;
        probinfo.warmStartFlag = defaults.nlp.ipoptoptions.warmstart;
        if probinfo.warmStartFlag == 0
              setup.nlp.ipoptoptions = rmfield(defaults.nlp.ipoptoptions,'warmstartmesh');
        elseif probinfo.warmStartFlag == 1
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmstartmesh = ',num2str(defaults.nlp.ipoptoptions.warmstartmesh)]);
              probinfo.warmStartMesh = defaults.nlp.ipoptoptions.warmstartmesh;
              if probinfo.warmStartMesh > 1
              probinfo.warmStartFlag = 0;
              end
        end
      end
    elseif strcmpi(setup.nlp.solver, 'snopt');
      % check if nlp.ipoptoptions is a field
      if isfield(usersetup.nlp,'ipoptoptions');
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.nlp.ipoptoptions because '...
          'setup.nlp.solver = ''',setup.nlp.solver,'''']);
        usersetup.nlp = rmfield(usersetup.nlp,'ipoptoptions');
      end
      
      % check usersetup.nlp for field 'snoptoptions'
      if isfield(usersetup.nlp,'snoptoptions');
        if ~isempty(usersetup.nlp.snoptoptions);
          if ~isstruct(usersetup.nlp.snoptoptions);
            error('GPOPS-II ERROR: setup.nlp.snoptoptions must be a structure');
          end
          if isfield(usersetup.nlp.snoptoptions,'tolerance');
            if ~isempty(usersetup.nlp.snoptoptions.tolerance);
              if isnumeric(usersetup.nlp.snoptoptions.tolerance);
                if size(usersetup.nlp.snoptoptions.tolerance,1) ~= 1 || size(usersetup.nlp.snoptoptions.tolerance,2) ~= 1;
                  % error usersetup.nlp.snoptoptions.tolerance is not a scalar
                  error('GPOPS-II ERROR: setup.nlp.snoptoptions.tolerance must be a scalar value');
                end
                if usersetup.nlp.snoptoptions.tolerance <= 0;
                  % error usersetup.nlp.snoptoptions.maxiterations is < 0
                  error('GPOPS-II ERROR: setup.nlp.snoptoptions.tolerance must be greater than 0');
                end
                setup.nlp.snoptoptions.tolerance = usersetup.nlp.snoptoptions.tolerance;
              else
                % error usersetup.nlp.snoptoptions.tolerance is not numeric
                error('GPOPS-II ERROR: setup.nlp.snoptoptions.tolerance must be a numerical value');
              end
            else
              % set default for snoptoptions.tolerance
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.tolerance = ',num2str(defaults.nlp.snoptoptions.tolerance)]);
              setup.nlp.snoptoptions.tolerance = defaults.nlp.snoptoptions.tolerance;
            end
            % remove field 'usersetup.nlp.snoptoptions.tolerance'
            usersetup.nlp.snoptoptions = rmfield(usersetup.nlp.snoptoptions,'tolerance');
          else
            % set default for snoptoptions.tolerance
            NumDefaults = NumDefaults + 1;
            DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.tolerance = ',num2str(defaults.nlp.snoptoptions.tolerance)]);
            setup.nlp.snoptoptions.tolerance = defaults.nlp.snoptoptions.tolerance;
          end
          
          if isfield(usersetup.nlp.snoptoptions,'maxiterations');
            if ~isempty(usersetup.nlp.snoptoptions.maxiterations);
              if isnumeric(usersetup.nlp.snoptoptions.maxiterations);
                if size(usersetup.nlp.snoptoptions.maxiterations,1) ~= 1 || size(usersetup.nlp.snoptoptions.maxiterations,2) ~= 1;
                  % error usersetup.nlp.snoptoptions.maxiterations is not a
                  % scalar
                  error('GPOPS-II ERROR: setup.nlp.snoptoptions.maxiterations must be a scalar value');
                end
                if ceil(usersetup.nlp.snoptoptions.maxiterations) ~= floor(usersetup.nlp.snoptoptions.maxiterations);
                  % error usersetup.nlp.snoptoptions.maxiterations is not an
                  % integer
                  error('GPOPS-II ERROR: setup.nlp.snoptoptions.maxiterations must be an integer value');
                end
                if usersetup.nlp.snoptoptions.maxiterations <= 0;
                  % error usersetup.nlp.snoptoptions.maxiterations is < 0
                  error('GPOPS-II ERROR: setup.nlp.snoptoptions.maxiterations must be greater than 0');
                end
                setup.nlp.snoptoptions.maxiterations = usersetup.nlp.snoptoptions.maxiterations;
              else
                % error usersetup.nlp.snoptoptions.maxiterations is not numeric
                error('GPOPS-II ERROR: setup.nlp.snoptoptions.maxiterations must be a numerical value');
              end
            else
              % set default for snoptoptions.maxiterations
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.maxiterations = ',num2str(defaults.nlp.snoptoptions.maxiterations)]);
              setup.nlp.snoptoptions.tolerance = defaults.nlp.snoptoptions.maxiterations;
            end
            % remove field 'usersetup.nlp.snoptoptions.maxiterations'
            usersetup.nlp.snoptoptions = rmfield(usersetup.nlp.snoptoptions,'maxiterations');
          else
            % set default for snoptoptions.maxiterations
            NumDefaults = NumDefaults + 1;
            DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.maxiterations = ',num2str(defaults.nlp.snoptoptions.maxiterations)]);
            setup.nlp.snoptoptions.maxiterations = defaults.nlp.snoptoptions.maxiterations;
          end
          
          if isfield(usersetup.nlp.snoptoptions,'warmstart');
              if ~isempty(usersetup.nlp.snoptoptions.warmstart);
                  if islogical(usersetup.nlp.snoptoptions.warmstart) || isnumeric(usersetup.nlp.snoptoptions.warmstart); %islogical, isnumeric
                     if size(usersetup.nlp.snoptoptions.warmstart,1) ~= 1 || size(usersetup.nlp.snoptoptions.warmstart,2) ~= 1;
                        % error usersetup.nlp.ipoptoptions.warmstart is not a scalar
                        error('GPOPS-II ERROR: setup.nlp.ipoptoptions.warmstart must be a scalar value');
                     end
                    if usersetup.nlp.snoptoptions.warmstart ~= 0 && usersetup.nlp.snoptoptions.warmstart~= 1
                       % error usersetup.nlp.snoptoptions.warmstart is not
                       % a boolean value
                        error('GPOPS-II ERROR: setup.nlp.snoptoptions.warmstart must be a numerical or logical value of 1 for true or 0 for false'); 
                    end
                    probinfo.warmStartFlag = usersetup.nlp.snoptoptions.warmstart;
                  else
                        % error usersetup.nlp.snoptoptions.warmstart is not numeric
                        error('GPOPS-II ERROR: setup.nlp.snoptoptions.warmstart must be a numerical or logical value of 1 for true or 0 for false');   
                  end
              else    
                % set default for ipoptoptions.warmstart
                NumDefaults = NumDefaults + 1;
                DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstart = ',num2str(defaults.nlp.snoptoptions.warmstart)]);
                probinfo.warmStartFlag = defaults.nlp.snoptoptions.warmstart;
              end
              % remove field 'usersetup.nlp.snoptoptions.warmstart'
              usersetup.nlp.snoptoptions = rmfield(usersetup.nlp.snoptoptions,'warmstart');
          else
            % set default for ipoptoptions.warmstart
            NumDefaults = NumDefaults + 1;
            DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstart = ',num2str(defaults.nlp.snoptoptions.warmstart)]);
            probinfo.warmStartFlag = defaults.nlp.snoptoptions.warmstart;
          end
          
          if isfield(usersetup.nlp.snoptoptions,'warmstartmesh');
              if probinfo.warmStartFlag == 1
                  if ~isempty(usersetup.nlp.snoptoptions.warmstartmesh);
                      if isnumeric(usersetup.nlp.snoptoptions.warmstartmesh);
                         if size(usersetup.nlp.snoptoptions.warmstartmesh,1) ~= 1 || size(usersetup.nlp.snoptoptions.warmstartmesh,2) ~= 1;
                            % error usersetup.nlp.ipoptoptions.warmstartmesh is not a scalar
                            error('GPOPS-II ERROR: setup.nlp.snoptoptions.warmstartmesh must be a scalar value');
                         end
                        if usersetup.nlp.snoptoptions.warmstartmesh ~= 1 && usersetup.nlp.snoptoptions.warmstartmesh ~= 2
                           % error usersetup.nlp.ipoptoptions.warmstartmesh is not
                           % 1st or 2nd
                            error('GPOPS-II ERROR: setup.nlp.snoptoptions.warmstartmesh must be a value of 1 or 2'); 
                        end
                        probinfo.warmStartMesh = usersetup.nlp.snoptoptions.warmstartmesh;
                        if probinfo.warmStartMesh > 1
                           probinfo.warmStartFlag = 0; 
                        end
                      else
                            % error usersetup.nlp.ipoptoptions.warmstartmesh is not numeric
                            error('GPOPS-II ERROR: setup.nlp.snoptoptions.warmstartmesh must be a numerical value.');   
                      end
                  else    
                    % set default for ipoptoptions.warmstartmesh
                    NumDefaults = NumDefaults + 1;
                    DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstartmesh = ',num2str(defaults.nlp.snoptoptions.warmstartmesh)]);
                    probinfo.warmStartMesh = defaults.nlp.snoptoptions.warmstartmesh;
                    if probinfo.warmStartMesh > 1
                       probinfo.warmStartFlag = 0; 
                    end
                  end
              else
                  NumWarnings = NumWarnings + 1;
                  WarningsStr{NumWarnings} = (['    Ignoring setup.nlp.snoptoptions.warmstartmesh as warmstart is off']);
              end
              % remove field 'usersetup.nlp.ipoptoptions.warmstartmesh'
              usersetup.nlp.snoptoptions = rmfield(usersetup.nlp.snoptoptions,'warmstartmesh');
          else
            % set default for snoptoptions.warmstartmesh
            if probinfo.warmStartFlag == 1
                NumDefaults = NumDefaults + 1;
                DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstartmesh = ',num2str(defaults.nlp.snoptoptions.warmstartmesh)]);
                probinfo.warmStartMesh = defaults.nlp.snoptoptions.warmstartmesh;
                if probinfo.warmStartMesh > 1
                   probinfo.warmStartFlag = 0; 
                end
            end
          end 
          
          % check usersetup.nlp.snoptoptions for unknown fields
          % valid fields are 'tolerance', 'maxiterations', 'warmstart',
          % 'warmstartmesh'
          URF = fieldnames(usersetup.nlp.snoptoptions);
          for URFcount = 1:size(URF,1);
            NumWarnings = NumWarnings + 1;
            WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.nlp.snoptoptions.',URF{URFcount}]);
          end
        else
          % set default for snopt nlp options
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.tolerance = ',num2str(defaults.nlp.snoptoptions.tolerance)]);
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.maxiterations = ',num2str(defaults.nlp.snoptoptions.maxiterations)]);
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstart = ',num2str(defaults.nlp.snoptoptions.warmstart)]);
          setup.nlp.snoptoptions = defaults.nlp.snoptoptions;
          probinfo.warmStartFlag = defaults.nlp.snoptoptions.warmstart;
          if probinfo.warmStartFlag == 0
              setup.nlp.snoptoptions = rmfield(defaults.nlp.snoptoptions,'warmstartmesh');
          elseif probinfo.warmStartFlag == 1
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstartmesh = ',num2str(defaults.nlp.snoptoptions.warmstartmesh)]);
              probinfo.warmStartMesh = defaults.nlp.snoptoptions.warmstartmesh;
              if probinfo.warmStartMesh > 1
              probinfo.warmStartFlag = 0;
              end
          end
        end
        
        % remove field 'usersetup.nlp.ipoptoptions'
        usersetup.nlp = rmfield(usersetup.nlp,'snoptoptions');
      else
        % set default for snopt nlp options
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.tolerance = ',num2str(defaults.nlp.snoptoptions.tolerance)]);
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.maxiterations = ',num2str(defaults.nlp.snoptoptions.maxiterations)]);
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstart = ',num2str(defaults.nlp.snoptoptions.warmstart)]);
        setup.nlp.snoptoptions = defaults.nlp.snoptoptions;
        probinfo.warmStartFlag = defaults.nlp.snoptoptions.warmstart;
        if probinfo.warmStartFlag == 0
              setup.nlp.snoptoptions = rmfield(defaults.nlp.snoptoptions,'warmstartmesh');
        elseif probinfo.warmStartFlag == 1
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstartmesh = ',num2str(defaults.nlp.snoptoptions.warmstartmesh)]);
              probinfo.warmStartMesh = defaults.nlp.snoptoptions.warmstartmesh;
              if probinfo.warmStartMesh > 1
              probinfo.warmStartFlag = 0;
              end
        end
      end
    end
    % check usersetup.nlp for unknown fields
    % valid fields are 'solver', 'ipoptoptions', 'snoptoptions'
    URF = fieldnames(usersetup.nlp);
    for URFcount = 1:size(URF,1);
      NumWarnings = NumWarnings + 1;
      WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.nlp.',URF{URFcount}]);
    end
  else
    % set default for all nlp options
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.solver = ''',defaults.nlp.solver,'''']);
    setup.nlp.solver = defaults.nlp.solver;
    if strcmpi(defaults.nlp.solver, 'ipopt');
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.linear_solver = ''',defaults.nlp.ipoptoptions.linear_solver,'''']);
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.tolerance = ',num2str(defaults.nlp.ipoptoptions.tolerance)]);
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.maxiterations = ',num2str(defaults.nlp.ipoptoptions.maxiterations)]);
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmstart = ',num2str(defaults.nlp.ipoptoptions.warmStart)]);
      setup.nlp.ipoptoptions = defaults.nlp.ipoptoptions;
      probinfo.warmStartFlag = defaults.nlp.ipoptoptions.warmStart;
      if probinfo.warmStartFlag == 0
          setup.nlp.ipoptoptions = rmfield(defaults.nlp.ipoptoptions,'warmstartmesh');
      elseif probinfo.warmStartFlag == 1
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmstartmesh = ',num2str(defaults.nlp.ipoptoptions.warmstartmesh)]);
          probinfo.warmStartMesh = defaults.nlp.ipoptoptions.warmstartmesh;
          if probinfo.warmStartMesh > 1
          probinfo.warmStartFlag = 0;
          end
      end
    elseif strcmpi(defaults.nlp.solver, 'snopt');
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.tolerance = ''',num2str(defaults.nlp.snoptoptions.tolerance)]);
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.maxiterations = ',num2str(defaults.nlp.snoptoptions.maxiterations)]);
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstart = ',num2str(defaults.nlp.snoptoptions.warmstart)]);
      setup.nlp.snoptoptions = defaults.nlp.snoptoptions;
      probinfo.warmStartFlag = defaults.nlp.snoptoptions.warmstart;
      if probinfo.warmStartFlag == 0
          setup.nlp.snoptoptions = rmfield(defaults.nlp.snoptoptions,'warmstartmesh');
      elseif probinfo.warmStartFlag == 1
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstartmesh = ',num2str(defaults.nlp.snoptoptions.warmstartmesh)]);
          probinfo.warmStartMesh = defaults.nlp.snoptoptions.warmstartmesh;
          if probinfo.warmStartMesh > 1
          probinfo.warmStartFlag = 0;
          end
      end
    end
  end
  
  % remove field 'usersetup.nlp.ipoptoptions'
  usersetup = rmfield(usersetup,'nlp');
else
  % set default for all nlp options
  NumDefaults = NumDefaults + 1;
  DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.solver = ''',defaults.nlp.solver,'''']);
  setup.nlp.solver = defaults.nlp.solver;
  if strcmpi(defaults.nlp.solver, 'ipopt');
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.linear_solver = ''',defaults.nlp.ipoptoptions.linear_solver,'''']);
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.tolerance = ',num2str(defaults.nlp.ipoptoptions.tolerance)]);
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.maxiterations = ',num2str(defaults.nlp.ipoptoptions.maxiterations)]);
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmStart = ',num2str(defaults.nlp.ipoptoptions.warmStart)]);
    setup.nlp.ipoptoptions = defaults.nlp.ipoptoptions;
    probinfo.warmStartFlag = defaults.nlp.ipoptoptions.warmStart;
    if probinfo.warmStartFlag == 0
          setup.nlp.ipoptoptions = rmfield(defaults.nlp.ipoptoptions,'warmstartmesh');
    elseif probinfo.warmStartFlag == 1
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.ipoptoptions.warmstartmesh = ',num2str(defaults.nlp.ipoptoptions.warmstartmesh)]);
          probinfo.warmStartMesh = defaults.nlp.ipoptoptions.warmstartmesh;
          if probinfo.warmStartMesh > 1
          probinfo.warmStartFlag = 0;
          end
    end
  elseif strcmpi(defaults.nlp.solver, 'snopt');
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.tolerance = ''',num2str(defaults.nlp.snoptoptions.tolerance)]);
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.maxiterations = ',num2str(defaults.nlp.snoptoptions.maxiterations)]);
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstart = ',num2str(defaults.nlp.snoptoptions.warmstart)]);
    setup.nlp.snoptoptions = defaults.nlp.snoptoptions;
    probinfo.warmStartFlag = defaults.nlp.snoptoptions.warmstart;
    if probinfo.warmStartFlag == 0
          setup.nlp.snoptoptions = rmfield(defaults.nlp.snoptoptions,'warmstartmesh');
    elseif probinfo.warmStartFlag == 1
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.nlp.snoptoptions.warmstartmesh = ',num2str(defaults.nlp.snoptoptions.warmstartmesh)]);
          probinfo.warmStartMesh = defaults.nlp.snoptoptions.warmstartmesh;
          if probinfo.warmStartMesh > 1
          probinfo.warmStartFlag = 0;
          end
    end
  end
end

% check if nlp solver is found
if strcmpi(setup.nlp.solver, 'ipopt');
  if (exist('ipopt','file') ~= 3) && (exist('ipopt','file') ~= 2);
    error('GPOPS-II ERROR: mex file for ''ipopt'' not found in path');
  end
end
if strcmpi(setup.nlp.solver, 'snopt');
  if exist('snoptmex','file') ~= 3 && exist('snoptcmex','file') ~= 3;
    error('GPOPS-II ERROR: mex file for ''snopt'' not found in path');
  end
end

% check usersetup for field 'auxdata'
if isfield(usersetup,'auxdata');
  setup.auxdata = usersetup.auxdata;
  % remove field 'auxdata'
  usersetup = rmfield(usersetup,'auxdata');
end

% check bounds
if isfield(usersetup,'bounds');
  if isfield(usersetup.bounds,'phase');
    % store usersetup.bounds.phase
    setup.bounds.phase = usersetup.bounds.phase;
    
    % get number of phases
    numphase = length(usersetup.bounds.phase);
    
    % check that phases in a single dimension
    if numphase ~= numel(usersetup.bounds.phase);
      % error phase not single dimension
      error('GPOPS-II ERROR: setup.bounds.phase must be a single dimension ');
    end
    
    % determine if any states exist
    if ~isfield(usersetup.bounds.phase,'initialtime');
      % error initialtime is not provided
      error(['GPOPS-II ERROR: the initial time bounds are required to be provided '...
        'in setup.bounds.phase.initialtime']);
    end
    
    % determine if finaltime exist
    if ~isfield(usersetup.bounds.phase,'finaltime');
      % error finaltime is not provided
      error(['GPOPS-II ERROR: the final time bounds are required to be provided '...
        'in setup.bounds.phase.finaltime']);
    end
    
    % determine if state exist
    if ~isfield(usersetup.bounds.phase,'state');
      % error state is not provided
      error(['GPOPS-II ERROR: the state bounds are required to be provided '...
        'in setup.bounds.phase.state']);
    end
    
    % determine if any statss exist
    if ~isfield(usersetup.bounds.phase,'initialstate');
      % error initialstate is not provided
      error(['GPOPS-II ERROR: the initial state bounds are required to be provided '...
        'in setup.bounds.phase.initialstate']);
    end
    
    % determine if finalstate exist
    if ~isfield(usersetup.bounds.phase,'finalstate');
      % error finalstate is not provided
      error(['GPOPS-II ERROR: the final state bounds are required to be provided '...
        'in setup.bounds.phase.finalstate']);
    end
    
    % determine if any controls exist
    if ~isfield(usersetup.bounds.phase,'control');
      usersetup.bounds.phase(numphase).control = [];
    end
    
    % determine if path constraints exist
    if ~isfield(usersetup.bounds.phase,'path');
      usersetup.bounds.phase(numphase).path = [];
    end
    
    % determine if integral constraints exist
    if ~isfield(usersetup.bounds.phase,'integral');
      usersetup.bounds.phase(numphase).integral = [];
    end
    
    % determine if duration constraints exist
    if ~isfield(usersetup.bounds.phase,'duration');
      usersetup.bounds.phase(numphase).duration = [];
    end
    
    % find number of states, controls, path constraints and
    % integral constraints in each phase
    % num_state, num_control, num_path, num_integral are all
    % (1 by num_phase) integer array
    % each value indicates the number for that phase
    numstate    = zeros(1,numphase);
    numcontrol  = zeros(1,numphase);
    numpath     = zeros(1,numphase);
    numintegral = zeros(1,numphase);
    phaseduration = false(1,numphase);
    for phasecount = 1:numphase;
      % check initialtime bounds
      if isfield(usersetup.bounds.phase(phasecount).initialtime,'lower') && isfield(usersetup.bounds.phase(phasecount).initialtime,'upper');
        if isnumeric(usersetup.bounds.phase(phasecount).initialtime.lower) && isnumeric(usersetup.bounds.phase(phasecount).initialtime.upper);
          if all(size(usersetup.bounds.phase(phasecount).initialtime.lower) == size(usersetup.bounds.phase(phasecount).initialtime.upper));
            if size(usersetup.bounds.phase(phasecount).initialtime.lower,1) == 1 && size(usersetup.bounds.phase(phasecount).initialtime.lower,2) == 1;
              if any(usersetup.bounds.phase(phasecount).initialtime.lower > usersetup.bounds.phase(phasecount).initialtime.upper);
                % error initialtime lower bound greater than upper bound
                error(['GPOPS-II ERROR: upper bound must be equal or greater than lower bound '...
                  'for setup.bounds.phase(',num2str(phasecount),').initialtime']);
              end
            else
              % error initialtime lower and upper bounds not scalars
              error(['GPOPS-II ERROR: upper and lower bounds must be a scalars '...
                'for setup.bounds.phase(',num2str(phasecount),').initialtime']);
            end
          else
            % error initialtime lower and upper bounds different sizes
            error(['GPOPS-II ERROR: upper and lower bounds must be the same size '...
              'for setup.bounds.phase(',num2str(phasecount),').initialtime']);
          end
        else
          % error initialtime lower and upper bounds not numeric
          error(['GPOPS-II ERROR: upper and lower bounds must be numeric '...
            'for setup.bounds.phase(',num2str(phasecount),').initialtime']);
        end
      else
        % error initialtime lower and upper bounds not provided
        error(['GPOPS-II ERROR: upper and lower bounds are required '...
          'for setup.bounds.phase(',num2str(phasecount),').initialtime']);
      end
      
      % check finaltime bounds
      if isfield(usersetup.bounds.phase(phasecount).finaltime,'lower') && isfield(usersetup.bounds.phase(phasecount).finaltime,'upper');
        if isnumeric(usersetup.bounds.phase(phasecount).finaltime.lower) && isnumeric(usersetup.bounds.phase(phasecount).finaltime.upper);
          if all(size(usersetup.bounds.phase(phasecount).finaltime.lower) == size(usersetup.bounds.phase(phasecount).finaltime.upper));
            if size(usersetup.bounds.phase(phasecount).finaltime.lower,1) == 1 && size(usersetup.bounds.phase(phasecount).finaltime.lower,2) == 1;
              if any(usersetup.bounds.phase(phasecount).finaltime.lower > usersetup.bounds.phase(phasecount).finaltime.upper);
                % error finaltime lower bound greater than upper bound
                error(['GPOPS-II ERROR: upper bound must be equal or greater than lower bound '...
                  'for setup.bounds.phase(',num2str(phasecount),').finaltime']);
              end
            else
              % error finaltime lower and upper bounds not scalars
              error(['GPOPS-II ERROR: upper and lower bounds must be a scalars '...
                'for setup.bounds.phase(',num2str(phasecount),').finaltime']);
            end
          else
            % error finaltime lower and upper bounds different sizes
            error(['GPOPS-II ERROR: upper and lower bounds must be the same size '...
              'for setup.bounds.phase(',num2str(phasecount),').finaltime']);
          end
        else
          % error finaltime lower and upper bounds not numeric
          error(['GPOPS-II ERROR: upper and lower bounds must be numeric '...
            'for setup.bounds.phase(',num2str(phasecount),').finaltime']);
        end
      else
        % error finaltime is not provided
        error(['GPOPS-II ERROR: upper and lower bounds are required '...
          'for setup.bounds.phase(',num2str(phasecount),').finaltime']);
      end
      
      % check state bounds
      if isfield(usersetup.bounds.phase(phasecount).state,'lower') && isfield(usersetup.bounds.phase(phasecount).state,'upper');
        if isnumeric(usersetup.bounds.phase(phasecount).state.lower) && isnumeric(usersetup.bounds.phase(phasecount).state.upper);
          if all(size(usersetup.bounds.phase(phasecount).state.lower) == size(usersetup.bounds.phase(phasecount).state.upper));
            if size(usersetup.bounds.phase(phasecount).state.lower,1) == 1;
              if any(usersetup.bounds.phase(phasecount).state.lower > usersetup.bounds.phase(phasecount).state.upper);
                % error state lower bound greater than upper bound
                error(['GPOPS-II ERROR: upper bound must be equal or greater than lower bound '...
                  'for setup.bounds.phase(',num2str(phasecount),').state']);
              end
              numstate(1,phasecount) = size(usersetup.bounds.phase(phasecount).state.lower,2);
            else
              % error state lower and upper bounds different sizes
              error(['GPOPS-II ERROR: upper and lower bounds must be row vectors '...
                'for setup.bounds.phase(',num2str(phasecount),').state']);
            end
          else
            % error state lower and upper bounds different sizes
            error(['GPOPS-II ERROR: upper and lower bounds must be the same size '...
              'for setup.bounds.phase(',num2str(phasecount),').state']);
          end
        else
          % error state lower and upper bounds not numeric
          error(['GPOPS-II ERROR: upper and lower bounds must be numeric '...
            'for setup.bounds.phase(',num2str(phasecount),').state']);
        end
      else
        % error state is not provided
        error(['GPOPS-II ERROR: upper and lower bounds are required '...
          'for setup.bounds.phase(',num2str(phasecount),').state']);
      end
      
      % check initialstate bounds
      if isfield(usersetup.bounds.phase(phasecount).initialstate,'lower') && isfield(usersetup.bounds.phase(phasecount).initialstate,'upper');
        if isnumeric(usersetup.bounds.phase(phasecount).initialstate.lower) && isnumeric(usersetup.bounds.phase(phasecount).initialstate.upper);
          if all(size(usersetup.bounds.phase(phasecount).initialstate.lower) == size(usersetup.bounds.phase(phasecount).initialstate.upper));
            if size(usersetup.bounds.phase(phasecount).initialstate.lower,1) == 1;
              if any(usersetup.bounds.phase(phasecount).initialstate.lower > usersetup.bounds.phase(phasecount).initialstate.upper);
                % error initialstate lower bound greater than upper bound
                error(['GPOPS-II ERROR: upper bound must be equal or greater than lower bound '...
                  'for setup.bounds.phase(',num2str(phasecount),').initialstate']);
              end
              if size(usersetup.bounds.phase(phasecount).initialstate.lower,2) ~= numstate(1,phasecount);
                % error initialstate lower and upper bounds different sizes
                error(['GPOPS-II ERROR: the bounds for setup.bounds.phase(',num2str(phasecount),').initialstate '...
                  'must be the same size as setup.bounds.phase(',num2str(phasecount),').state']);
              end
            else
              % error initialstate lower and upper bounds different sizes
              error(['GPOPS-II ERROR: upper and lower bounds must be row vectors '...
                'for setup.bounds.phase(',num2str(phasecount),').initialstate']);
            end
          else
            % error initialstate lower and upper bounds different sizes
            error(['GPOPS-II ERROR: upper and lower bounds must be the same size '...
              'for setup.bounds.phase(',num2str(phasecount),').initialstate']);
          end
        else
          % error initialstate lower and upper bounds not numeric
          error(['GPOPS-II ERROR: upper and lower bounds must be numeric '...
            'for setup.bounds.phase(',num2str(phasecount),').initialstate']);
        end
      else
        % error initialstate is not provided
        error(['GPOPS-II ERROR: upper and lower bounds are required '...
          'for setup.bounds.phase(',num2str(phasecount),').initialstate']);
      end
      
      % check finalstate bounds
      if isfield(usersetup.bounds.phase(phasecount).finalstate,'lower') && isfield(usersetup.bounds.phase(phasecount).finalstate,'upper');
        if isnumeric(usersetup.bounds.phase(phasecount).finalstate.lower) && isnumeric(usersetup.bounds.phase(phasecount).finalstate.upper);
          if all(size(usersetup.bounds.phase(phasecount).finalstate.lower) == size(usersetup.bounds.phase(phasecount).finalstate.upper));
            if size(usersetup.bounds.phase(phasecount).finalstate.lower,1) == 1;
              if any(usersetup.bounds.phase(phasecount).finalstate.lower > usersetup.bounds.phase(phasecount).finalstate.upper);
                % error finalstate lower bound greater than upper bound
                error(['GPOPS-II ERROR: upper bound must be equal or greater than lower bound '...
                  'for setup.bounds.phase(',num2str(phasecount),').finalstate']);
              end
              if size(usersetup.bounds.phase(phasecount).finalstate.lower,2) ~= numstate(1,phasecount);
                % error finalstate lower and upper bounds different sizes
                error(['GPOPS-II ERROR: the bounds for setup.bounds.phase(',num2str(phasecount),').finalstate '...
                  'must be the same size as setup.bounds.phase(',num2str(phasecount),').state']);
              end
            else
              % error finalstate lower and upper bounds different sizes
              error(['GPOPS-II ERROR: upper and lower bounds must be row vectors '...
                'for setup.bounds.phase(',num2str(phasecount),').finalstate']);
            end
          else
            % error finalstate lower and upper bounds different sizes
            error(['GPOPS-II ERROR: upper and lower bounds must be the same size '...
              'for setup.bounds.phase(',num2str(phasecount),').finalstate']);
          end
        else
          % error finalstate lower and upper bounds not numeric
          error(['GPOPS-II ERROR: upper and lower bounds must be numeric '...
            'for setup.bounds.phase(',num2str(phasecount),').finalstate']);
        end
      else
        % error finalstate is not provided
        error(['GPOPS-II ERROR: upper and lower bounds are required '...
          'for setup.bounds.phase(',num2str(phasecount),').finalstate']);
      end
      
      % check control bounds
      if ~isempty(usersetup.bounds.phase(phasecount).control);
        if isfield(usersetup.bounds.phase(phasecount).control,'lower') && isfield(usersetup.bounds.phase(phasecount).control,'upper');
          if isnumeric(usersetup.bounds.phase(phasecount).control.lower) && isnumeric(usersetup.bounds.phase(phasecount).control.upper);
            if all(size(usersetup.bounds.phase(phasecount).control.lower) == size(usersetup.bounds.phase(phasecount).control.upper));
              if size(usersetup.bounds.phase(phasecount).control.lower,1) == 1;
                if any(usersetup.bounds.phase(phasecount).control.lower > usersetup.bounds.phase(phasecount).control.upper);
                  % error control lower bound greater than upper bound
                  error(['GPOPS-II ERROR: upper bound must be equal or greater than lower bound '...
                    'for setup.bounds.phase(',num2str(phasecount),').control']);
                end
                numcontrol(1,phasecount) = size(usersetup.bounds.phase(phasecount).control.lower,2);
              else
                % error control lower and upper bounds different sizes
                error(['GPOPS-II ERROR: upper and lower bounds must be row vectors '...
                  'for setup.bounds.phase(',num2str(phasecount),').control']);
              end
            else
              % error control lower and upper bounds different sizes
              error(['GPOPS-II ERROR: upper and lower bounds must be the same size '...
                'for setup.bounds.phase(',num2str(phasecount),').control']);
            end
          else
            % error control lower and upper bounds not numeric
            error(['GPOPS-II ERROR: upper and lower bounds must be numeric '...
              'for setup.bounds.phase(',num2str(phasecount),').control']);
          end
        else
          % error control is not provided
          error(['GPOPS-II ERROR: upper and lower bounds are required '...
            'for setup.bounds.phase(',num2str(phasecount),').control']);
        end
      end
      
      % check path bounds
      if ~isempty(usersetup.bounds.phase(phasecount).path);
        if isfield(usersetup.bounds.phase(phasecount).path,'lower') && isfield(usersetup.bounds.phase(phasecount).path,'upper');
          if isnumeric(usersetup.bounds.phase(phasecount).path.lower) && isnumeric(usersetup.bounds.phase(phasecount).path.upper);
            if all(size(usersetup.bounds.phase(phasecount).path.lower) == size(usersetup.bounds.phase(phasecount).path.upper));
              if size(usersetup.bounds.phase(phasecount).path.lower,1) == 1;
                if any(usersetup.bounds.phase(phasecount).path.lower > usersetup.bounds.phase(phasecount).path.upper);
                  % error path lower bound greater than upper bound
                  error(['GPOPS-II ERROR: upper bound must be equal or greater than lower bound '...
                    'for setup.bounds.phase(',num2str(phasecount),').path']);
                end
                numpath(1,phasecount) = size(usersetup.bounds.phase(phasecount).path.lower,2);
              else
                % error path lower and upper bounds different sizes
                error(['GPOPS-II ERROR: upper and lower bounds must be row vectors '...
                  'for setup.bounds.phase(',num2str(phasecount),').path']);
              end
            else
              % error path lower and upper bounds different sizes
              error(['GPOPS-II ERROR: upper and lower bounds must be the same size '...
                'for setup.bounds.phase(',num2str(phasecount),').path']);
            end
          else
            % error path lower and upper bounds not numeric
            error(['GPOPS-II ERROR: upper and lower bounds must be numeric '...
              'for setup.bounds.phase(',num2str(phasecount),').path']);
          end
        else
          % error path is not provided
          error(['GPOPS-II ERROR: upper and lower bounds are required '...
            'for setup.bounds.phase(',num2str(phasecount),').path']);
        end
      end
      
      % check integral bounds
      if ~isempty(usersetup.bounds.phase(phasecount).integral);
        if isfield(usersetup.bounds.phase(phasecount).integral,'lower') && isfield(usersetup.bounds.phase(phasecount).integral,'upper');
          if isnumeric(usersetup.bounds.phase(phasecount).integral.lower) && isnumeric(usersetup.bounds.phase(phasecount).integral.upper);
            if all(size(usersetup.bounds.phase(phasecount).integral.lower) == size(usersetup.bounds.phase(phasecount).integral.upper));
              if size(usersetup.bounds.phase(phasecount).integral.lower,1) == 1;
                if any(usersetup.bounds.phase(phasecount).integral.lower > usersetup.bounds.phase(phasecount).integral.upper);
                  % error integral lower bound greater than upper bound
                  error(['GPOPS-II ERROR: upper bound must be equal or greater than lower bound '...
                    'for setup.bounds.phase(',num2str(phasecount),').integral']);
                end
                numintegral(1,phasecount) = size(usersetup.bounds.phase(phasecount).integral.lower,2);
              else
                % error integral lower and upper bounds different sizes
                error(['GPOPS-II ERROR: upper and lower bounds must be row vectors '...
                  'for setup.bounds.phase(',num2str(phasecount),').integral']);
              end
            else
              % error integral lower and upper bounds different sizes
              error(['GPOPS-II ERROR: upper and lower bounds must be the same size '...
                'for setup.bounds.phase(',num2str(phasecount),').integral']);
            end
          else
            % error integral lower and upper bounds not numeric
            error(['GPOPS-II ERROR: upper and lower bounds must be numeric '...
              'for setup.bounds.phase(',num2str(phasecount),').integral']);
          end
        else
          % error integral is not provided
          error(['GPOPS-II ERROR: upper and lower bounds are required '...
            'for setup.bounds.phase(',num2str(phasecount),').integral']);
        end
      end
      
      % check duration bounds
      if ~isempty(usersetup.bounds.phase(phasecount).duration);
        % find what phases have duration constraints
        % phase_duration is (1 by num_phase) logical array
        % false when no defined duration is in phase, true when defined duration exist
        phaseduration(1,phasecount) = true;
        if isfield(usersetup.bounds.phase(phasecount).duration,'lower') && isfield(usersetup.bounds.phase(phasecount).duration,'upper');
          if isnumeric(usersetup.bounds.phase(phasecount).duration.lower) && isnumeric(usersetup.bounds.phase(phasecount).duration.upper);
            if all(size(usersetup.bounds.phase(phasecount).duration.lower) == size(usersetup.bounds.phase(phasecount).duration.upper));
              if size(usersetup.bounds.phase(phasecount).duration.lower,1) == 1 && size(usersetup.bounds.phase(phasecount).duration.lower,2) == 1;
                if any(usersetup.bounds.phase(phasecount).duration.lower > usersetup.bounds.phase(phasecount).duration.upper);
                  % error duration lower bound greater than upper bound
                  error(['GPOPS-II ERROR: upper bound must be equal or greater than lower bound '...
                    'for setup.bounds.phase(',num2str(phasecount),').duration']);
                end
              else
                % error duration lower and upper bounds not scalars
                error(['GPOPS-II ERROR: upper and lower bounds must be scalars '...
                  'for setup.bounds.phase(',num2str(phasecount),').duration']);
              end
            else
              % error duration lower and upper bounds different sizes
              error(['GPOPS-II ERROR: upper and lower bounds must be the same size '...
                'for setup.bounds.phase(',num2str(phasecount),').duration']);
            end
          else
            % error duration lower and upper bounds not numeric
            error(['GPOPS-II ERROR: upper and lower bounds must be numeric '...
              'for setup.bounds.phase(',num2str(phasecount),').duration']);
          end
        else
          % error duration is not provided
          error(['GPOPS-II ERROR: upper and lower bounds are required '...
            'for setup.bounds.phase(',num2str(phasecount),').duration']);
        end
      end
    end %end phase loop
    
    % check usersetup.bounds.phase for unknown fields
    % valid fields are 'initialtime', 'finaltime', 'initialstate', 'finalstate',
    % 'state', 'control', 'path', 'integral', 'duration'
    usersetup.bounds.phase = rmfield(usersetup.bounds.phase,'initialtime');
    usersetup.bounds.phase = rmfield(usersetup.bounds.phase,'finaltime');
    usersetup.bounds.phase = rmfield(usersetup.bounds.phase,'initialstate');
    usersetup.bounds.phase = rmfield(usersetup.bounds.phase,'finalstate');
    usersetup.bounds.phase = rmfield(usersetup.bounds.phase,'state');
    usersetup.bounds.phase = rmfield(usersetup.bounds.phase,'control');
    usersetup.bounds.phase = rmfield(usersetup.bounds.phase,'path');
    usersetup.bounds.phase = rmfield(usersetup.bounds.phase,'integral');
    usersetup.bounds.phase = rmfield(usersetup.bounds.phase,'duration');
    
    URF = fieldnames(usersetup.bounds.phase);
    for URFcount = 1:size(URF,1);
      NumWarnings = NumWarnings + 1;
      WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.bounds.phase.',URF{URFcount}]);
    end
    
    % remove field 'usersetup.bounds.phase'
    usersetup.bounds = rmfield(usersetup.bounds,'phase');
  else
    % error bounds is not provided
    error(['GPOPS-II ERROR: the bounds for each phase are required to be provided '...
      'in setup.bounds.phase']);
  end
  
  % find parameter bounds
  if isfield(usersetup.bounds,'parameter');
    if isfield(usersetup.bounds.parameter,'lower') && isfield(usersetup.bounds.parameter,'upper');
      if isnumeric(usersetup.bounds.parameter.lower) && isnumeric(usersetup.bounds.parameter.upper);
        if all(size(usersetup.bounds.parameter.lower) == size(usersetup.bounds.parameter.upper));
          if size(usersetup.bounds.parameter.lower,1) == 1;
            if any(usersetup.bounds.parameter.lower > usersetup.bounds.parameter.upper);
              % error parameter lower bound greater than upper bound
              error(['GPOPS-II ERROR: upper bound must be equal or greater than lower bound '...
                'for setup.bounds.parameter']);
            end
          else
            % error parameter lower and upper bounds different sizes
            error(['GPOPS-II ERROR: upper and lower bounds must be row vectors '...
              'for setup.bounds.parameter']);
          end
        else
          % error parameter lower and upper bounds different sizes
          error(['GPOPS-II ERROR: upper and lower bounds must be the same size '...
            'for setup.bounds.parameter']);
        end
      else
        % error path lower and upper bounds not numeric
        error(['GPOPS-II ERROR: upper and lower bounds must be numeric '...
          'for setup.bounds.parameter']);
      end
    else
      % error parameter is not provided
      error(['GPOPS-II ERROR: upper and lower bounds are required '...
        'for setup.bounds.parameter']);
    end
    % store setup.bounds.parameter
    setup.bounds.parameter = usersetup.bounds.parameter;
    
    % remove field 'usersetup.bounds.parameter'
    usersetup.bounds = rmfield(usersetup.bounds,'parameter');
    
    % store numparameter
    numparameter = size(setup.bounds.parameter.lower,2);
  else
    numparameter = 0;
  end
  
  % find number of eventgroups and number of events per each eventgroup
  % num_event is (1 by num_eventgroups) integer array
  % each value indicates the number of events for that eventgroup
  if isfield(usersetup.bounds,'eventgroup');
    % get number of eventgroups
    numeventgroup = length(usersetup.bounds.eventgroup);
    
    % check that eventgroup in a single dimension
    if numeventgroup ~= numel(usersetup.bounds.eventgroup);
      % error phase not single dimension
      error('GPOPS-II ERROR: setup.bounds.eventgroup must be a single dimension ');
    end
    
    numevent = zeros(1,numeventgroup);
    for eventgroupcount = 1:numeventgroup;
      if isfield(usersetup.bounds.eventgroup(eventgroupcount),'lower') && isfield(usersetup.bounds.eventgroup(eventgroupcount),'upper');
        if isnumeric(usersetup.bounds.eventgroup(eventgroupcount).lower) && isnumeric(usersetup.bounds.eventgroup(eventgroupcount).upper);
          if all(size(usersetup.bounds.eventgroup(eventgroupcount).lower) == size(usersetup.bounds.eventgroup(eventgroupcount).upper));
            if size(usersetup.bounds.eventgroup(eventgroupcount).lower,1) == 1;
              if any(usersetup.bounds.eventgroup(eventgroupcount).lower > usersetup.bounds.eventgroup(eventgroupcount).upper);
                % error event lower bound greater than upper bound
                error(['GPOPS-II ERROR: upper bound must be equal or greater than lower bound '...
                  'for setup.bounds.eventgroup(',num2str(eventgroupcount),')']);
              end
              numevent(1,eventgroupcount) = size(usersetup.bounds.eventgroup(eventgroupcount).lower,2);
            else
              % error event lower and upper bounds different sizes
              error(['GPOPS-II ERROR: upper and lower bounds must be row vectors '...
                'for setup.bounds.eventgroup(',num2str(eventgroupcount),')']);
            end
          else
            % error event lower and upper bounds different sizes
            error(['GPOPS-II ERROR: upper and lower bounds must be the same size '...
              'for setup.bounds.eventgroup(',num2str(eventgroupcount),')']);
          end
        else
          % error event lower and upper bounds not numeric
          error(['GPOPS-II ERROR: upper and lower bounds must be numeric '...
            'for setup.bounds.eventgroup(',num2str(eventgroupcount),')']);
        end
      else
        % error event is not provided
        error(['GPOPS-II ERROR: upper and lower bounds are required '...
          'for setup.bounds.eventgroup']);
      end
    end
    % store setup.bounds.eventgroup
    setup.bounds.eventgroup = usersetup.bounds.eventgroup;
    
    % remove field 'usersetup.bounds.eventgroup'
    usersetup.bounds = rmfield(usersetup.bounds,'eventgroup');
  else
    % store numeventgroup and numevent
    numeventgroup = 0;
    numevent = 0;
  end
  
  % find if initial and final times are fixed in each phase
  % fixedtime.flag is (2 by numphase) logical array
  % row 1 represents intial, row 2 represents final
  % 1 if time is fixed, 0 if free
  %
  % fixedtime.value is (1 by numphase) double array
  % contains the values of the fixed initial or final time
  % (only valid when the corresponding flag is 1)
  fixedtimeflag  = false(2,numphase);
  fixedtimevalue = zeros(2,numphase);
  for phasecount = 1:numphase;
    % check initial time
    if setup.bounds.phase(phasecount).initialtime.lower == setup.bounds.phase(phasecount).initialtime.upper;
      fixedtimeflag(1,phasecount)  = true;
      fixedtimevalue(1,phasecount) = setup.bounds.phase(phasecount).initialtime.lower;
    end
    % check final time
    if setup.bounds.phase(phasecount).finaltime.lower == setup.bounds.phase(phasecount).finaltime.upper;
      fixedtimeflag(2,phasecount)  = true;
      fixedtimevalue(2,phasecount) = setup.bounds.phase(phasecount).finaltime.lower;
    end
  end
  
  % check usersetup.bounds for unknown fields
  % valid fields are 'phase', 'parameter', 'eventgroup'
  URF = fieldnames(usersetup.bounds);
  for URFcount = 1:size(URF,1);
    NumWarnings = NumWarnings + 1;
    WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.bounds.',URF{URFcount}]);
  end
  
  % remove field 'usersetup.bounds'
  usersetup = rmfield(usersetup,'bounds');
else
  % error bounds is not provided
  error('GPOPS-II ERROR: setup.bounds is required');
end

% check guess
if isfield(usersetup,'guess');
    
  if isfield(usersetup.guess,'eventgroupmultipliers');
    % store usersetup.guess.eventgroupmultipliers
    if probinfo.warmStartFlag == 1
        setup.guess.eventgroupmultipliers = usersetup.guess.eventgroupmultipliers;  
        guessevents = length(usersetup.guess.eventgroupmultipliers);
        if guessevents ~= numel(usersetup.guess.eventgroupmultipliers);
          % error phase not single dimension
          error('GPOPS-II ERROR: setup.guess.eventgroupmultipliers must be a single dimension ');
        end
        % guess must be provided for each phase
        if guessevents ~= numeventgroup;
          error(['GPOPS-II ERROR: the initial guess must be provided for each '...
            'event group, setup.guess.eventgroupmultipliers needs to be the same size as setup.bounds.eventgroup']);
        end
        for i = 1:1:numeventgroup 
            % check to make sure multipliers is same length as event bounds
            if numevent(i) == size(usersetup.guess.eventgroupmultipliers(i).eventmult,2);
            else
                error(['GPOPS-II ERROR: setup.guess.eventgroupmultipliers needs to be the same size as setup.bounds.eventgroup']);
            end
        end
    else
        NumWarnings = NumWarnings + 1;
        WarningsStr{NumWarnings} = (['    Ignoring setup.guess.eventgroupmultipliers']); 
    end
    %remove event group multipliers
    usersetup.guess = rmfield(usersetup.guess,'eventgroupmultipliers');
  else
      if probinfo.warmStartFlag && numeventgroup > 0
          error(['GPOPS-II ERROR: setup.guess.eventgroupmultipliers is required for each '...
        'event group as warmstart is turned on for the first mesh']);
      end    
  end   
  
  if isfield(usersetup.guess,'eventgroupbasis');
    % store usersetup.guess.eventgroupmultipliers
    if probinfo.warmStartFlag == 1 && strcmp(setup.nlp.solver, 'snopt');
        setup.guess.eventgroupbasis = usersetup.guess.eventgroupbasis;  
        guessevents = length(usersetup.guess.eventgroupbasis);
        if guessevents ~= numel(usersetup.guess.eventgroupbasis);
          % error phase not single dimension
          error('GPOPS-II ERROR: setup.guess.eventgroupbasis must be a single dimension ');
        end
        % guess must be provided for each phase
        if guessevents ~= numeventgroup;
          error(['GPOPS-II ERROR: the initial guess must be provided for each '...
            'event group, setup.guess.eventgroupbasis needs to be the same size as setup.bounds.eventgroup']);
        end
        for i = 1:1:numeventgroup 
            % check to make sure multipliers is same length as event bounds
            if numevent(i) == size(usersetup.guess.eventgroupbasis(i).eventbasis,2);
            else
                error(['GPOPS-II ERROR: setup.guess.eventgroupbasis needs to be the same size as setup.bounds.eventgroup']);
            end
        end       
    else
        NumWarnings = NumWarnings + 1;
        WarningsStr{NumWarnings} = (['    Ignoring setup.guess.eventgroupbasis']); 
    end
    %remove event group multipliers
    usersetup.guess = rmfield(usersetup.guess,'eventgroupbasis');
  else
      if probinfo.warmStartFlag && numeventgroup && strcmp(setup.nlp.solver, 'snopt') > 0
          error(['GPOPS-II ERROR: setup.guess.eventgroupbasis is required for each '...
        'event group as warmstart is turned on for the first mesh while using ''snopt'' ']);
      end    
  end 
  
  if isfield(usersetup.guess,'phase');
    % store usersetup.guess.phase
    setup.guess.phase = usersetup.guess.phase;
    
    % check that phases in a single dimension
    guessphases = length(usersetup.guess.phase);
    if guessphases ~= numel(usersetup.guess.phase);
      % error phase not single dimension
      error('GPOPS-II ERROR: setup.guess.phase must be a single dimension ');
    end
    
    % guess must be provided for each phase
    if guessphases ~= numphase;
      error(['GPOPS-II ERROR: the initial guess must be provided for each '...
        'phase, setup.guess.phase needs to be the same size as setup.bounds.phase']);
    end
    
    % determine if any states exist
    if ~isfield(usersetup.guess.phase,'time');
      % error initialtime is not provided
      error(['GPOPS-II ERROR: the time guess is required to be '...
        'in setup.guess.phase.time']);
    end
    
    % determine if state exist
    if ~isfield(usersetup.guess.phase,'state');
      % error state is not provided
      error(['GPOPS-II ERROR: the state guess is required to be '...
        'in setup.guess.phase.state']);
    end
    
    % dertermine if any controls exist
    if ~isfield(usersetup.guess.phase,'control');
      usersetup.guess.phase(numphase).control = [];
    end
    
    % determine if integral constraints exist
    if ~isfield(usersetup.guess.phase,'integral');
      usersetup.guess.phase(numphase).integral = [];
    end
    
    if probinfo.warmStartFlag == 1
        % determine if costate exist
        if ~isfield(usersetup.guess.phase,'costate');
            % error state is not provided
            error(['GPOPS-II ERROR: the costate guess is required to be '...
            'in setup.guess.phase.costate for warmStart']);
        end
        % determine if integral multipliers exist
        if ~isfield(usersetup.guess.phase,'integralmultipliers') && any(numintegral);
            % error integral multipliers is not provided
            error(['GPOPS-II ERROR: the integral multipliers guess is required to be '...
            'in setup.guess.phase.integralmultipliers for warmStart']);
        end
        % determine if duration multipliers exist
        if ~isfield(usersetup.guess.phase,'durationmultipliers');
            % error duration multipliers is not provided
            error(['GPOPS-II ERROR: the duration multipliers guess is required to be '...
            'in setup.guess.phase.durationmultipliers for warmStart']);
        end
        % determine if bound multipliers exist
        if ~isfield(usersetup.guess.phase,'boundmultipliers');
            % error bound multipliers is not provided
            error(['GPOPS-II ERROR: the bound multipliers guess is required to be '...
            'in setup.guess.phase.boundmultipliers for warmStart']);
        end
        for i = 1:1:numphase
            % determine if state multipliers exist
            if ~isfield(usersetup.guess.phase(i).boundmultipliers,'statemult');
                % error state multipliers is not provided
                error(['GPOPS-II ERROR: the state multipliers guess for phase ',num2str(i),' is required to be '...
                'in setup.guess.phase.boundmultipliers.statemult for warmstart']);
            end
            % determine if control multipliers exist
            if ~isfield(usersetup.guess.phase(i).boundmultipliers,'controlmult');
                % error state multipliers is not provided
                error(['GPOPS-II ERROR: the control multipliers guess for phase ',num2str(i),' is required to be '...
                'in setup.guess.phase.boundmultipliers.controlmult for warmstart']);
            end
            % determine if time multipliers exist
            if ~isfield(usersetup.guess.phase(i).boundmultipliers,'t0tfmult');
                % error state multipliers is not provided
                error(['GPOPS-II ERROR: the time multipliers guess for phase ',num2str(i),' is required to be '...
                'in setup.guess.phase.boundmultipliers.t0tfmult for warmstart']);
            end
        end
        % determine if path multipliers exist
        if ~isfield(usersetup.guess.phase,'pathmultipliers') && any(numpath);
            % error path multipliers is not provided
            error(['GPOPS-II ERROR: the path multipliers guess is required to be '...
            'in setup.guess.phase.pathmultipliers for warmstart']);
        end
    else
        % determine if costate exist
        if isfield(usersetup.guess.phase,'costate');
            NumWarnings = NumWarnings + 1;
            WarningsStr{NumWarnings} = (['    Ignoring setup.guess.phase.costate']); 
            %remove costate multipliers
            usersetup.guess.phase = rmfield(usersetup.guess.phase,'costate');
            setup.guess.phase = rmfield(setup.guess.phase,'costate');
        end
        % determine if duration multipliers exist
        if isfield(usersetup.guess.phase,'durationmultipliers');
            NumWarnings = NumWarnings + 1;
            WarningsStr{NumWarnings} = (['    Ignoring setup.guess.phase.durationmultipliers']);
            %remove duration multipliers
            usersetup.guess.phase = rmfield(usersetup.guess.phase,'durationmultipliers');
            setup.guess.phase = rmfield(setup.guess.phase,'durationmultipliers');
        end
        % determine if integral multipliers exist
        if isfield(usersetup.guess.phase,'integralmultipliers');
            NumWarnings = NumWarnings + 1;
            WarningsStr{NumWarnings} = (['    Ignoring setup.guess.phase.integralmultipliers']);
            %remove duration multipliers
            usersetup.guess.phase = rmfield(usersetup.guess.phase,'integralmultipliers');
            setup.guess.phase = rmfield(setup.guess.phase,'integralmultipliers');
        end
        % determine if bound multipliers exist
        if isfield(usersetup.guess.phase,'boundmultipliers');
            NumWarnings = NumWarnings + 1;
            WarningsStr{NumWarnings} = (['    Ignoring setup.guess.phase.boundmultipliers']); 
            %remove bound multipliers
            usersetup.guess.phase = rmfield(usersetup.guess.phase,'boundmultipliers');
            setup.guess.phase = rmfield(setup.guess.phase,'boundmultipliers');
        end
        % determine if path multipliers exist
        if isfield(usersetup.guess.phase,'pathmultipliers');
            NumWarnings = NumWarnings + 1;
            WarningsStr{NumWarnings} = (['    Ignoring setup.guess.phase.pathmultipliers']); 
            %remove path multipliers
            usersetup.guess.phase = rmfield(usersetup.guess.phase,'pathmultipliers');
            setup.guess.phase = rmfield(setup.guess.phase,'pathmultipliers');
        end
    end
    
    for phasecount = 1:numphase;
      % check time guess
      if isnumeric(usersetup.guess.phase(phasecount).time);
        if size(usersetup.guess.phase(phasecount).time,2) == 1 && size(usersetup.guess.phase(phasecount).time,1) > 1;
          if ~all(diff(usersetup.guess.phase(phasecount).time) > 0);
            % error time monotonically increasing
            error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').time '...
              'must be monotonically increasing']);
          end
          % get length of guess
          guesslength = size(usersetup.guess.phase(phasecount).time,1);
        else
          % error time must have minimum of 2 points
          error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').time '...
            'must be a column vector containing at least 2 time points']);
        end
      else
        % error time not monotonically increasing
        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').time '...
          'must be numeric']);
      end
      
      % check state guess
      if isnumeric(usersetup.guess.phase(phasecount).state);
        if size(usersetup.guess.phase(phasecount).state,2) == numstate(phasecount);
          if size(usersetup.guess.phase(phasecount).state,1) ~= guesslength;
            % error state must be same length as time guess
            error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').state '...
              'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time']);
          end
        else
          % error state must have guess for each state
          error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').state '...
            'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').state']);
        end
      else
        % error state not numeric
        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').state '...
          'must be numeric']);
      end
      
      % check control guess
      if numcontrol(phasecount) > 0;
        if ~isempty(usersetup.guess.phase(phasecount).control);
          if isnumeric(usersetup.guess.phase(phasecount).control);
            if size(usersetup.guess.phase(phasecount).control,2) == numcontrol(phasecount);
              if size(usersetup.guess.phase(phasecount).control,1) ~= guesslength;
                % error control must be same length as time guess
                error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').control '...
                  'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time']);
              end
            else
              % error control must have guess for each control
              error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').control '...
                'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').control']);
            end
          else
            % error control not numeric
            error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').control '...
              'must be numeric']);
          end
        else
          % error control guess provided when control is empty
          error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').control '...
            'required because setup.bounds.phase(',num2str(phasecount),').control was provided']);
        end
      else
        if ~isfield(usersetup.guess.phase,'control');
          % error control guess provided when control is empty
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    setup.guess.phase(',num2str(phasecount),').control is being ignored '...
            'because setup.bounds.phase(',num2str(phasecount),').control is empty']);
        end
      end
      
      % check integral guess
      if numintegral(phasecount) > 0;
        if ~isempty(usersetup.guess.phase(phasecount).integral);
          if isnumeric(usersetup.guess.phase(phasecount).integral);
            if size(usersetup.guess.phase(phasecount).integral,2) == numintegral(phasecount);
              if size(usersetup.guess.phase(phasecount).integral,1) ~= 1;
                % error integral must be same length as time guess
                error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').integral '...
                  'must be a row vector']);
              end
            else
              % error integral must have guess for each integral
              error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').integral '...
                'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').integral']);
            end
          else
            % error integral not numeric
            error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').integral '...
              'must be numeric']);
          end
        else
          % error integral guess provided when integral is empty
          error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').integral '...
            'required because setup.bounds.phase(',num2str(phasecount),').integral was provided']);
        end
      else
        if ~isfield(usersetup.guess.phase,'integral');
          % error integral guess provided when integral is empty
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    setup.guess.phase(',num2str(phasecount),').integral is being ignored '...
            'because setup.bounds.phase(',num2str(phasecount),').integral is empty']);
        end
      end
      
        if probinfo.warmStartFlag == 1
            % check costate guess
            if ~isempty(usersetup.guess.phase(phasecount).costate);
                  if isnumeric(usersetup.guess.phase(phasecount).costate);
                    if size(usersetup.guess.phase(phasecount).costate,2) == numstate(phasecount);
                      if size(usersetup.guess.phase(phasecount).costate,1) ~= guesslength;
                        % error costate must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').costate '...
                          'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time']);
                      end
                    else
                      % error costate must have guess for each state
                      error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').costate '...
                        'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').state']);
                    end
                  else
                    % error costate not numeric
                    error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').costate '...
                      'must be numeric']);
                  end
            else
                % error costate error
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').costate '...
                    'required because setup.bounds.phase(',num2str(phasecount),').state was provided']);
            end

            % check duration multipliers guess %one number
            if ~isempty(usersetup.guess.phase(phasecount).durationmultipliers);
              if isnumeric(usersetup.guess.phase(phasecount).durationmultipliers);
                if size(usersetup.guess.phase(phasecount).durationmultipliers,2) == 1 && size(usersetup.guess.phase(phasecount).durationmultipliers,1) == 1;
                else
                  % error duration multipliers must have guess for each phase
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').durationmultipliers '...
                    'must be a single value']);
                end
              else
                % error duration multipliers not numeric
                error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').durationmultipliers '...
                  'must be numeric']);
              end
            else
              % error duration multipliers guess provided
              error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').durationmultipliers is'...
                'required because warmStart is on']);
            end

            % check integral multipliers guess 
            if numintegral(phasecount) > 0;
            if ~isempty(usersetup.guess.phase(phasecount).integralmultipliers);
              if isnumeric(usersetup.guess.phase(phasecount).integralmultipliers);
                if size(usersetup.guess.phase(phasecount).integralmultipliers,2) == numintegral(phasecount) && size(usersetup.guess.phase(phasecount).integralmultipliers,1) == 1;
                else
                  % error duration multipliers must have guess for each phase
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').integralmultipliers '...
                    'must be the size of the number of integrals']);
                end
              else
                % error duration multipliers not numeric
                error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').integralmultipliers '...
                  'must be numeric']);
              end
            else
              % error duration multipliers guess provided when integral is empty
              error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').integralmultipliers is'...
                'required because warmStart is on']);
            end
            end

            % check bound multipliers guess %% consists of statemult,
            % controlmult, t0tfmult, Qmult
            
            if strcmp(setup.nlp.solver, 'ipopt')
            % statemult
                if ~isempty(usersetup.guess.phase(phasecount).boundmultipliers.statemult);
                  if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.statemult.l);
                    if size(usersetup.guess.phase(phasecount).boundmultipliers.statemult.l,2) == numstate(phasecount);
                      if size(usersetup.guess.phase(phasecount).boundmultipliers.statemult.l,1) ~= guesslength;
                        % error state must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.statemult.l '...
                          'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time']);
                      end
                    else
                      % error statemult must have guess for each state
                      error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.statemult.l '...
                        'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').state']);
                    end
                  else
                    % error statemult not numeric
                    error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.statemult.l '...
                      'must be numeric']);
                  end
                  if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.statemult.u);
                    if size(usersetup.guess.phase(phasecount).boundmultipliers.statemult.u,2) == numstate(phasecount);
                      if size(usersetup.guess.phase(phasecount).boundmultipliers.statemult.u,1) ~= guesslength;
                        % error control must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.statemult.u '...
                          'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time']);
                      end
                    else
                      % error statemult must have guess for each state
                      error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.statemult.u '...
                        'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').state']);
                    end
                  else
                    % error statemult not numeric
                    error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.statemult.u '...
                      'must be numeric']);
                  end
                else
                  % error control guess provided when control is empty
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.statemult.l '...
                    'required because setup.bounds.phase(',num2str(phasecount),').state was provided']);
                end

            % controlmult
               if numcontrol(phasecount) > 0;
                if ~isempty(usersetup.guess.phase(phasecount).boundmultipliers.controlmult);
                  if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.controlmult.l);
                    if size(usersetup.guess.phase(phasecount).boundmultipliers.controlmult.l,2) == numcontrol(phasecount);
                      if size(usersetup.guess.phase(phasecount).boundmultipliers.controlmult.l,1) ~= guesslength-1;
                        % error control must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult.l '...
                          'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time minus 1']);
                      end
                    else
                      % error control must have guess for each control
                      error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult.l '...
                        'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').control']);
                    end
                  else
                    % error control not numeric
                    error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult.l '...
                      'must be numeric']);
                  end
                  if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.controlmult.u);
                    if size(usersetup.guess.phase(phasecount).boundmultipliers.controlmult.u,2) == numcontrol(phasecount);
                      if size(usersetup.guess.phase(phasecount).boundmultipliers.controlmult.u,1) ~= guesslength-1;
                        % error control must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult.u '...
                          'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time minus 1']);
                      end
                    else
                      % error control must have guess for each control
                      error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult.u '...
                        'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').control']);
                    end
                  else
                    % error control not numeric
                    error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult.u '...
                      'must be numeric']);
                  end
                else
                  % error control guess provided when control is empty
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult.l '...
                    'required because setup.bounds.phase(',num2str(phasecount),').control was provided']);
                end
              else
                if isfield(usersetup.guess.phase(phasecount).boundmultipliers,'controlmult');
                  % error control guess provided when control is empty
                  NumConflicts = NumConflicts + 1;
                  ConflictsStr{NumConflicts} = (['    setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult is being ignored '...
                    'because setup.bounds.phase(',num2str(phasecount),').control is empty']);
                end
               end

            % t0tfmult   
            if ~isempty(usersetup.guess.phase(phasecount).boundmultipliers.t0tfmult);
              if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.t0tfmult.l);
                if size(usersetup.guess.phase(phasecount).boundmultipliers.t0tfmult.l,2) == 1 && size(usersetup.guess.phase(phasecount).boundmultipliers.t0tfmult.l,1) == 2;
                else
                  % error t0tf bound multipliers must have guess for each phase
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.t0tfmult.l '...
                    'must be a 2 by 1 array']);
                end
              else
                % error t0tf bound multipliers not numeric
                error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.t0tfmult.l '...
                  'must be numeric']);
              end
              if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.t0tfmult.u);
                if size(usersetup.guess.phase(phasecount).boundmultipliers.t0tfmult.u,2) == 1 && size(usersetup.guess.phase(phasecount).boundmultipliers.t0tfmult.u,1) == 2;
                else
                  % error t0tf bound multipliers must have guess for each phase
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.t0tfmult.u '...
                    'must be a 2 by 1 array']);
                end
              else
                % error t0tf bound multipliers not numeric
                error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.t0tfmult.u '...
                  'must be numeric']);
              end
            else
              % error bound multipliers t0tf guess not provided
              error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.t0tfmult is'...
                'required because warmstart is on']);
            end

           % Qmult
               if numintegral(phasecount) > 0;
                if ~isempty(usersetup.guess.phase(phasecount).boundmultipliers.Qmult);
                  if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.Qmult.l);
                    if size(usersetup.guess.phase(phasecount).boundmultipliers.Qmult.l,1) == numintegral(phasecount);
                      if size(usersetup.guess.phase(phasecount).boundmultipliers.Qmult.l,2) ~= 1;
                        % error control must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult.l '...
                          'must have one row of integral multipliers in phase(',num2str(phasecount),')']);
                      end
                    else
                      % error control must have guess for each control
                      error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult.l '...
                        'must have the same number of columns as integrals in phase(',num2str(phasecount),')']);
                    end
                  else
                    % error control not numeric
                    error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult.l '...
                      'must be numeric']);
                  end
                  if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.Qmult.u);
                    if size(usersetup.guess.phase(phasecount).boundmultipliers.Qmult.u,1) == numintegral(phasecount);
                      if size(usersetup.guess.phase(phasecount).boundmultipliers.Qmult.u,2) ~= 1;
                        % error control must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult.u '...
                          'must have one row of integral multipliers in phase(',num2str(phasecount),')']);
                      end
                    else
                      % error control must have guess for each control
                      error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult.u '...
                        'must have the same number of columns as integrals in phase(',num2str(phasecount),')']);
                    end
                  else
                    % error control not numeric
                    error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult.u '...
                      'must be numeric']);
                  end
                else
                  % error control guess provided when control is empty
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult '...
                    'required because setup.bounds.phase(',num2str(phasecount),').integral was provided']);
                end
              else
                if isfield(usersetup.guess.phase(phasecount).boundmultipliers,'Qmult');
                  % error control guess provided when control is empty
                  NumConflicts = NumConflicts + 1;
                  ConflictsStr{NumConflicts} = (['    setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult is being ignored '...
                    'because setup.bounds.phase(',num2str(phasecount),').integral is empty']);
                end
               end 

            elseif strcmp(setup.nlp.solver, 'snopt')
            % statemult
                if ~isempty(usersetup.guess.phase(phasecount).boundmultipliers.statemult);
                  if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.statemult);
                    if size(usersetup.guess.phase(phasecount).boundmultipliers.statemult,2) == numstate(phasecount);
                      if size(usersetup.guess.phase(phasecount).boundmultipliers.statemult,1) ~= guesslength;
                        % error state must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.statemult '...
                          'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time']);
                      end
                    else
                      % error statemult must have guess for each state
                      error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.statemult '...
                        'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').state']);
                    end
                  else
                    % error statemult not numeric
                    error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.statemult '...
                      'must be numeric']);
                  end
                else
                  % error control guess provided when control is empty
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.statemult '...
                    'required because setup.bounds.phase(',num2str(phasecount),').state was provided']);
                end

            % controlmult
               if numcontrol(phasecount) > 0;
                if ~isempty(usersetup.guess.phase(phasecount).boundmultipliers.controlmult);
                  if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.controlmult);
                    if size(usersetup.guess.phase(phasecount).boundmultipliers.controlmult,2) == numcontrol(phasecount);
                      if size(usersetup.guess.phase(phasecount).boundmultipliers.controlmult,1) ~= guesslength-1;
                        % error control must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult '...
                          'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time -1']);
                      end
                    else
                      % error control must have guess for each control
                      error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult '...
                        'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').control']);
                    end
                  else
                    % error control not numeric
                    error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult '...
                      'must be numeric']);
                  end
                else
                  % error control guess provided when control is empty
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult '...
                    'required because setup.bounds.phase(',num2str(phasecount),').control was provided']);
                end
              else
                if isfield(usersetup.guess.phase(phasecount).boundmultipliers,'controlmult');
                  % error control guess provided when control is empty
                  NumConflicts = NumConflicts + 1;
                  ConflictsStr{NumConflicts} = (['    setup.guess.phase(',num2str(phasecount),').boundmultipliers.controlmult is being ignored '...
                    'because setup.bounds.phase(',num2str(phasecount),').control is empty']);
                end
               end

            % t0tfmult   
            if ~isempty(usersetup.guess.phase(phasecount).boundmultipliers.t0tfmult);
              if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.t0tfmult);
                if size(usersetup.guess.phase(phasecount).boundmultipliers.t0tfmult,2) == 1 && size(usersetup.guess.phase(phasecount).boundmultipliers.t0tfmult,1) == 2;
                else
                  % error t0tf bound multipliers must have guess for each phase
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.t0tfmult '...
                    'must be a 2 by 1 array']);
                end
              else
                % error t0tf bound multipliers not numeric
                error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.t0tfmult '...
                  'must be numeric']);
              end
            else
              % error bound multipliers t0tf guess not provided
              error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.t0tfmult is'...
                'required because warmstart is on']);
            end

           % Qmult
               if numintegral(phasecount) > 0;
                if ~isempty(usersetup.guess.phase(phasecount).boundmultipliers.Qmult);
                  if isnumeric(usersetup.guess.phase(phasecount).boundmultipliers.Qmult);
                    if size(usersetup.guess.phase(phasecount).boundmultipliers.Qmult,1) == numintegral(phasecount);
                      if size(usersetup.guess.phase(phasecount).boundmultipliers.Qmult,2) ~= 1;
                        % error control must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult '...
                          'must have one row of integral multipliers in phase(',num2str(phasecount),')']);
                      end
                    else
                      % error control must have guess for each control
                      error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult '...
                        'must have the same number of columns as integrals in phase(',num2str(phasecount),')']);
                    end
                  else
                    % error control not numeric
                    error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult '...
                      'must be numeric']);
                  end
                else
                  % error control guess provided when control is empty
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult '...
                    'required because setup.bounds.phase(',num2str(phasecount),').integral was provided']);
                end
              else
                if isfield(usersetup.guess.phase(phasecount).boundmultipliers,'Qmult');
                  % error control guess provided when control is empty
                  NumConflicts = NumConflicts + 1;
                  ConflictsStr{NumConflicts} = (['    setup.guess.phase(',num2str(phasecount),').boundmultipliers.Qmult is being ignored '...
                    'because setup.bounds.phase(',num2str(phasecount),').integral is empty']);
                end
               end    
                
            end

           % check path multipliers guess
          if numpath(phasecount) > 0;
            if ~isempty(usersetup.guess.phase(phasecount).pathmultipliers);
              if isnumeric(usersetup.guess.phase(phasecount).pathmultipliers);
                if size(usersetup.guess.phase(phasecount).pathmultipliers,2) == numpath(phasecount);
                  if size(usersetup.guess.phase(phasecount).pathmultipliers,1) ~= guesslength-1;
                    % error control must be same length as time guess
                    error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').pathmultipliers '...
                      'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time minus 1']);
                  end
                else
                  % error control must have guess for each control
                  error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').pathmultipliers '...
                    'must have the same number of columns as path constraints for phase(',num2str(phasecount),')']);
                end
              else
                % error control not numeric
                error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').pathmultipliers '...
                  'must be numeric']);
              end
            else
              % error control guess provided when control is empty
              error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').pathmultipliers '...
                'required because there is a path constraint in phase(',num2str(phasecount),')']);
            end
          else
            if isfield(usersetup.guess.phase,'pathmultipliers');
              % error control guess provided when control is empty
              NumConflicts = NumConflicts + 1;
              ConflictsStr{NumConflicts} = (['    setup.guess.phase(',num2str(phasecount),').pathmultipliers is being ignored '...
                'because there is no path constraint in phase(',num2str(phasecount),')']);
            end
          end
        end      
    end
    
    % check usersetup.bounds.phase for unknown fields
    % valid fields are 'time', 'state', 'control',
    % 'integral','costate','durationmultipliers','boundmultipliers','pathmultipliers'
    usersetup.guess.phase = rmfield(usersetup.guess.phase,'time');
    usersetup.guess.phase = rmfield(usersetup.guess.phase,'state');
    usersetup.guess.phase = rmfield(usersetup.guess.phase,'control');
    usersetup.guess.phase = rmfield(usersetup.guess.phase,'integral');
    
    if probinfo.warmStartFlag == 1
        usersetup.guess.phase = rmfield(usersetup.guess.phase,'costate');
        usersetup.guess.phase = rmfield(usersetup.guess.phase,'durationmultipliers');
        usersetup.guess.phase = rmfield(usersetup.guess.phase,'boundmultipliers');
        if any(numpath)
            usersetup.guess.phase = rmfield(usersetup.guess.phase,'pathmultipliers');
        end
        if any(numintegral)
            usersetup.guess.phase = rmfield(usersetup.guess.phase,'integralmultipliers');
        end
    end
    
    URF = fieldnames(usersetup.guess.phase);
    for URFcount = 1:size(URF,1);
      NumWarnings = NumWarnings + 1;
      WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.guess.phase.',URF{URFcount}]);
    end
    
    % remove field 'usersetup.guess.phase'
    usersetup.guess = rmfield(usersetup.guess,'phase');
  else
    % error guess is not provided
    error(['GPOPS-II ERROR: the guess for each phase is required to be provided '...
      'in setup.guess.phase']);
  end
  
  % find basis guess if needed for snopt
  if probinfo.warmStartFlag == 1 && strcmp(setup.nlp.solver, 'snopt');
     if isfield(usersetup.guess,'basis');
        % store usersetup.guess.basis
        setup.guess.basis = usersetup.guess.basis;
        
        if isfield(usersetup.guess.basis,'phase');
        % check that phases in a single dimension
        guessphases = length(usersetup.guess.basis.phase);
        if guessphases ~= numel(usersetup.guess.basis.phase);
          % error phase not single dimension
          error('GPOPS-II ERROR: setup.guess.basis.phase must be a single dimension ');
        end

        % guess must be provided for each phase
        if guessphases ~= numphase;
          error(['GPOPS-II ERROR: the initial guess must be provided for each '...
            'phase, setup.guess.basis.phase needs to be the same size as setup.bounds.phase']);
        end

        % determine if costate basis exist
        if ~isfield(usersetup.guess.basis.phase,'defectbasis');
            % error state is not provided
            error(['GPOPS-II ERROR: the defect basis guess is required to be '...
            'in setup.guess.basis.phase.defectbasis for warmstart']);
        end
        % determine if integral basis exist
        if ~isfield(usersetup.guess.basis.phase,'integralbasis') && any(numintegral);
            % error integral basis is not provided
            error(['GPOPS-II ERROR: the integral basis guess is required to be '...
            'in setup.guess.basis.phase.integralbasis for warmstart']);
        end
        % determine if duration basis exist
        if ~isfield(usersetup.guess.basis.phase,'durationbasis');
            % error duration basis is not provided
            error(['GPOPS-II ERROR: the duration basis guess is required to be '...
            'in setup.guess.basis.phase.durationbasis for warmstart']);
        end
        % determine if bound basis exist
        if ~isfield(usersetup.guess.basis.phase,'boundbasis');
            % error bound basis is not provided
            error(['GPOPS-II ERROR: the bound basis guess is required to be '...
            'in setup.guess.basis.phase.boundbasis for warmstart']);
        end
        for i = 1:1:numphase
            % determine if state basis exist
            if ~isfield(usersetup.guess.basis.phase(i).boundbasis,'statebasis');
                % error state basis is not provided
                error(['GPOPS-II ERROR: the state basis guess for phase ',num2str(i),' is required to be '...
                'in setup.guess.basis.phase.boundbasis.statebasis for warmstart']);
            end
            % determine if control basis exist
            if ~isfield(usersetup.guess.basis.phase(i).boundbasis,'controlbasis');
                % error state basis is not provided
                error(['GPOPS-II ERROR: the control basis guess for phase ',num2str(i),' is required to be '...
                'in setup.guess.basis.phase.boundbasis.controlbasis for warmstart']);
            end
            % determine if time basis exist
            if ~isfield(usersetup.guess.basis.phase(i).boundbasis,'t0tfbasis');
                % error state basis is not provided
                error(['GPOPS-II ERROR: the time basis guess for phase ',num2str(i),' is required to be '...
                'in setup.guess.basis.phase.boundbasis.t0tfbasis for warmstart']);
            end
        end
        % determine if path basis exist
        if ~isfield(usersetup.guess.basis.phase,'pathbasis') && any(numpath);
            % error path basis is not provided
            error(['GPOPS-II ERROR: the path basis guess is required to be '...
            'in setup.guess.basis.phase.pathbasis for warmstart']);
        end

        for phasecount = 1:numphase;
            % get length of guess
            guesslength = size(setup.guess.phase(phasecount).time,1);
            % check costate guess
            if ~isempty(usersetup.guess.basis.phase(phasecount).defectbasis);
                  if isnumeric(usersetup.guess.basis.phase(phasecount).defectbasis);
                    if size(usersetup.guess.basis.phase(phasecount).defectbasis,2) == numstate(phasecount);
                      if size(usersetup.guess.basis.phase(phasecount).defectbasis,1) ~= guesslength-1;
                        % error costate must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').defectbasis '...
                          'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time -1']);
                      end
                    else
                      % error costate must have guess for each state
                      error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').defectbasis '...
                        'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').state']);
                    end
                  else
                    % error costate not numeric
                    error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').defectbasis '...
                      'must be numeric']);
                  end
            else
                % error costate error
                  error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').defectbasis '...
                    'required because setup.bounds.phase(',num2str(phasecount),').state was provided']);
            end
            
                % check duration basis guess %one number
                if ~isempty(usersetup.guess.basis.phase(phasecount).durationbasis);
                  if isnumeric(usersetup.guess.basis.phase(phasecount).durationbasis);
                    if size(usersetup.guess.basis.phase(phasecount).durationbasis,2) == 1 && size(usersetup.guess.basis.phase(phasecount).durationbasis,1) == 1;
                    else
                      % error duration basis must have guess for each phase
                      error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').durationbasis '...
                        'must be a single value']);
                    end
                  else
                    % error duration basis not numeric
                    error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').durationbasis '...
                      'must be numeric']);
                  end
                else
                  % error duration basis guess provided
                  error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').durationbasis is'...
                    'required because warmstart is on']);
                end

                % check integral basis guess 
                if numintegral(phasecount) > 0;
                if ~isempty(usersetup.guess.basis.phase(phasecount).integralbasis);
                  if isnumeric(usersetup.guess.basis.phase(phasecount).integralbasis);
                    if size(usersetup.guess.basis.phase(phasecount).integralbasis,2) == numintegral(phasecount) && size(usersetup.guess.basis.phase(phasecount).integralbasis,1) == 1;
                    else
                      % error duration basis must have guess for each phase
                      error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').integralbasis '...
                        'must be the size of the number of integrals']);
                    end
                  else
                    % error duration basis not numeric
                    error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').integralbasis '...
                      'must be numeric']);
                  end
                else
                  % error duration basis guess provided when integral is empty
                  error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').integralbasis is'...
                    'required because warmstart is on']);
                end
                end

                % check bound basis guess %% consists of statebasis,
                % controlbasis, t0tfbasis, Qbasis

                % statebasis
                    if ~isempty(usersetup.guess.basis.phase(phasecount).boundbasis.statebasis);
                      if isnumeric(usersetup.guess.basis.phase(phasecount).boundbasis.statebasis);
                        if size(usersetup.guess.basis.phase(phasecount).boundbasis.statebasis,2) == numstate(phasecount);
                          if size(usersetup.guess.basis.phase(phasecount).boundbasis.statebasis,1) ~= guesslength;
                            % error statebasis must be same length as time guess
                            error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.statebasis '...
                              'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time']);
                          end
                        else
                          % error statebasis must have guess for each state
                          error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.statebasis '...
                            'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').state']);
                        end
                      else
                        % error statebasis not numeric
                        error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.statebasis '...
                          'must be numeric']);
                      end
                    else
                      % error statebasis needed
                      error(['GPOPS-II ERROR: setup.guess.phase(',num2str(phasecount),').boundbasis.statebasis '...
                        'required because setup.bounds.phase(',num2str(phasecount),').state was provided']);
                    end

                % controlbasis
                   if numcontrol(phasecount) > 0;
                    if ~isempty(usersetup.guess.basis.phase(phasecount).boundbasis.controlbasis);
                      if isnumeric(usersetup.guess.basis.phase(phasecount).boundbasis.controlbasis);
                        if size(usersetup.guess.basis.phase(phasecount).boundbasis.controlbasis,2) == numcontrol(phasecount);
                          if size(usersetup.guess.basis.phase(phasecount).boundbasis.controlbasis,1) ~= guesslength-1;
                            % error control must be same length as time guess
                            error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.controlbasis '...
                              'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time -1']);
                          end
                        else
                          % error control must have guess for each control
                          error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.controlbasis '...
                            'must have the same number of columns as setup.bounds.phase(',num2str(phasecount),').control']);
                        end
                      else
                        % error control not numeric
                        error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.controlbasis '...
                          'must be numeric']);
                      end
                    else
                      % error control basis provided when control is empty
                      error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.controlbasis '...
                        'required because setup.bounds.phase(',num2str(phasecount),').control was provided']);
                    end
                  else
                    if isfield(usersetup.guess.basis.phase(phasecount).boundbasis,'controlbasis');
                      % error control guess provided when control is empty
                      NumConflicts = NumConflicts + 1;
                      ConflictsStr{NumConflicts} = (['    setup.guess.basis.phase(',num2str(phasecount),').boundbasis.controlbasis is being ignored '...
                        'because setup.bounds.phase(',num2str(phasecount),').control is empty']);
                    end
                   end

                % t0tfmult   
                if ~isempty(usersetup.guess.basis.phase(phasecount).boundbasis.t0tfbasis);
                  if isnumeric(usersetup.guess.basis.phase(phasecount).boundbasis.t0tfbasis);
                    if size(usersetup.guess.basis.phase(phasecount).boundbasis.t0tfbasis,2) == 1 && size(usersetup.guess.basis.phase(phasecount).boundbasis.t0tfbasis,1) == 2;
                    else
                      % error t0tf bound multipliers must have guess for each phase
                      error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.t0tfbasis '...
                        'must be a 2 by 1 array']);
                    end
                  else
                    % error t0tf bound multipliers not numeric
                    error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.t0tfbasis '...
                      'must be numeric']);
                  end
                else
                  % error bound multipliers t0tf guess not provided
                  error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.t0tfbasis is'...
                    'required because warmstart is on']);
                end

               % Qmult
                   if numintegral(phasecount) > 0;
                    if ~isempty(usersetup.guess.basis.phase(phasecount).boundbasis.Qbasis);
                      if isnumeric(usersetup.guess.basis.phase(phasecount).boundbasis.Qbasis);
                        if size(usersetup.guess.basis.phase(phasecount).boundbasis.Qbasis,1) == numintegral(phasecount);
                          if size(usersetup.guess.basis.phase(phasecount).boundbasis.Qbasis,2) ~= 1;
                            % error control must be same length as time guess
                            error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.Qbasis '...
                              'must have one row of integral multipliers in phase(',num2str(phasecount),')']);
                          end
                        else
                          % error control must have guess for each control
                          error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.Qbasis '...
                            'must have the same number of columns as integrals in phase(',num2str(phasecount),')']);
                        end
                      else
                        % error control not numeric
                        error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.Qbasis '...
                          'must be numeric']);
                      end
                    else
                      % error control guess provided when control is empty
                      error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').boundbasis.Qbasis '...
                        'required because setup.bounds.phase(',num2str(phasecount),').integral was provided']);
                    end
                  else
                    if isfield(usersetup.guess.basis.phase(phasecount).boundbasis,'Qbasis');
                      % error control guess provided when control is empty
                      NumConflicts = NumConflicts + 1;
                      ConflictsStr{NumConflicts} = (['    setup.guess.basis.phase(',num2str(phasecount),').boundbasis.Qbasis is being ignored '...
                        'because setup.bounds.phase(',num2str(phasecount),').integral is empty']);
                    end
                   end    

               % check path basis guess
              if numpath(phasecount) > 0;
                if ~isempty(usersetup.guess.basis.phase(phasecount).pathbasis);
                  if isnumeric(usersetup.guess.basis.phase(phasecount).pathbasis);
                    if size(usersetup.guess.basis.phase(phasecount).pathbasis,2) == numpath(phasecount);
                      if size(usersetup.guess.basis.phase(phasecount).pathbasis,1) ~= guesslength-1;
                        % error path basis must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').pathbasis '...
                          'must have the same number of rows as setup.guess.phase(',num2str(phasecount),').time -1']);
                      end
                    else
                      % error path basis must have guess for each control
                      error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').pathbasis '...
                        'must have the same number of columns as path constraints for phase(',num2str(phasecount),')']);
                    end
                  else
                    % error pathbasis not numeric
                    error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').pathbasis '...
                      'must be numeric']);
                  end
                else
                  % error pathbasis guess provided when path is empty
                  error(['GPOPS-II ERROR: setup.guess.basis.phase(',num2str(phasecount),').pathbasis '...
                    'required because there is a path constraint in phase(',num2str(phasecount),')']);
                end
              else
                if isfield(usersetup.guess.basis.phase,'pathbasis');
                  % error control guess provided when control is empty
                  NumConflicts = NumConflicts + 1;
                  ConflictsStr{NumConflicts} = (['    setup.guess.basis.phase(',num2str(phasecount),').pathbasis is being ignored '...
                    'because there is no path constraint in phase(',num2str(phasecount),')']);
                end
              end 
        end
        % check usersetup.guess.basis.phase for unknown fields
        % valid fields are
        % 'defectbasis','durationbasis','boundbasis','pathbasis',
        % 'integralbasis'
        usersetup.guess.basis.phase = rmfield(usersetup.guess.basis.phase,'defectbasis');
        usersetup.guess.basis.phase = rmfield(usersetup.guess.basis.phase,'durationbasis');
        usersetup.guess.basis.phase = rmfield(usersetup.guess.basis.phase,'boundbasis');
        if any(numpath)
            usersetup.guess.basis.phase = rmfield(usersetup.guess.basis.phase,'pathbasis');
        end
        if any(numintegral)
            usersetup.guess.basis.phase = rmfield(usersetup.guess.basis.phase,'integralbasis');
        end

        URF = fieldnames(usersetup.guess.basis.phase);
        for URFcount = 1:size(URF,1);
          NumWarnings = NumWarnings + 1;
          WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.guess.basis.phase.',URF{URFcount}]);
        end
        
        % remove field 'usersetup.guess.basis.phase'
        usersetup.guess = rmfield(usersetup.guess,'basis');
        
        else
            % error guess is not provided
            error(['GPOPS-II ERROR: the guess for the phase is required to be provided '...
          'in setup.guess.basis.phase']);
        end
      else
        % error guess is not provided
            error(['GPOPS-II ERROR: the guess for the basis is required to be provided '...
          'in setup.guess.basis']);
     end
  else   
     if isfield(usersetup.guess,'basis')
        NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    setup.guess.basis is being ignored because ' ...
              'either warm start is off or nlp is not ''snopt'' ']);
         usersetup.guess = rmfield(usersetup.guess,'basis');
     end
  end
  
  % find parameter guess
  if numparameter > 0;
    if isfield(usersetup.guess, 'parameter');
      if isnumeric(usersetup.guess.parameter);
        if size(usersetup.guess.parameter,2) == numparameter;
          if size(usersetup.guess.parameter,1) ~= 1;
            % error parameter must be same length as time guess
            error(['GPOPS-II ERROR: setup.guess.parameter '...
              'must be a row vector']);
          end
        else
          % error parameter must have guess for each integral
          error(['GPOPS-II ERROR: setup.guess.parameter '...
            'must have the same number of columns as setup.bounds.parameter']);
        end
      else
        % error parameter not numeric
        error(['GPOPS-II ERROR: setup.guess.parameter '...
          'must be numeric']);
      end
    else
      % error parameter guess provided when parameter is empty
      error(['GPOPS-II ERROR: setup.guess.parameter '...
        'required because setup.bounds.parameter was provided']);
    end
    % store setup.bounds.parameter
    setup.guess.parameter = usersetup.guess.parameter;
    
    % remove field 'usersetup.bounds.parameter'
    usersetup.guess = rmfield(usersetup.guess,'parameter');
    
    if probinfo.warmStartFlag == 1 && strcmp(setup.nlp.solver, 'ipopt');
        if isfield(usersetup.guess,'staticparametermultipliers');
            if isfield(usersetup.guess.staticparametermultipliers,'l');
               if isnumeric(usersetup.guess.staticparametermultipliers.l);
                    if size(usersetup.guess.staticparametermultipliers.l,2) == numparameter;
                      if size(usersetup.guess.staticparametermultipliers.l,1) ~= 1;
                        % error parameter must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers.l '...
                          'must be a row vector']);
                      end
                    else
                      % error parameter must have guess for each integral
                      error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers.l '...
                        'must have the same number of columns as setup.bounds.parameter']);
                    end
               else
                    % error parameter not numeric
                    error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers.l '...
                      'must be numeric']);
               end
            else
               error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers.l '...
            'required because setup.bounds.parameter was provided and warmstart is on']); 
            end
            if isfield(usersetup.guess.staticparametermultipliers,'u');
               if isnumeric(usersetup.guess.staticparametermultipliers.u);
                    if size(usersetup.guess.staticparametermultipliers.u,2) == numparameter;
                      if size(usersetup.guess.staticparametermultipliers.u,1) ~= 1;
                        % error parameter must be same length as time guess
                        error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers.u '...
                          'must be a row vector']);
                      end
                    else
                      % error parameter must have guess for each integral
                      error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers.u '...
                        'must have the same number of columns as setup.bounds.parameter']);
                    end
               else
                    % error parameter not numeric
                    error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers.u '...
                      'must be numeric']);
               end
            else
               error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers.u '...
            'required because setup.bounds.parameter was provided and warmstart is on']); 
            end
        else
          % error parameter guess provided when parameter is empty
          error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers '...
            'required because setup.bounds.parameter was provided and warmstart is on']);
        end
        % store setup.bounds.parameter
        setup.guess.staticparametermultipliers = usersetup.guess.staticparametermultipliers;

        % remove field 'usersetup.bounds.parameter'
        usersetup.guess = rmfield(usersetup.guess,'staticparametermultipliers');
    end
    
    if probinfo.warmStartFlag == 1 && strcmp(setup.nlp.solver, 'snopt');
        if isfield(usersetup.guess,'staticparametermultipliers');
           if isnumeric(usersetup.guess.staticparametermultipliers);
                if size(usersetup.guess.staticparametermultipliers,2) == numparameter;
                  if size(usersetup.guess.staticparametermultipliers,1) ~= 1;
                    % error parameter must be same length as time guess
                    error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers '...
                      'must be a row vector']);
                  end
                else
                  % error parameter must have guess for each integral
                  error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers '...
                    'must have the same number of columns as setup.bounds.parameter']);
                end
           else
                % error parameter not numeric
                error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers '...
                  'must be numeric']);
           end
        else
          % error parameter guess provided when parameter is empty
          error(['GPOPS-II ERROR: setup.guess.staticparametermultipliers '...
            'required because setup.bounds.parameter was provided and warmstart is on']);
        end
        % store setup.bounds.parameter
        setup.guess.staticparametermultipliers = usersetup.guess.staticparametermultipliers;

        % remove field 'usersetup.bounds.parameter'
        usersetup.guess = rmfield(usersetup.guess,'staticparametermultipliers');
        
       if isfield(usersetup.guess,'staticparameterbasis');
           if isnumeric(usersetup.guess.staticparameterbasis);
                if size(usersetup.guess.staticparameterbasis,2) == numparameter;
                  if size(usersetup.guess.staticparameterbasis,1) ~= 1;
                    % error parameter must be same length as time guess
                    error(['GPOPS-II ERROR: setup.guess.staticparameterbasis '...
                      'must be a row vector']);
                  end
                else
                  % error parameter must have guess for each integral
                  error(['GPOPS-II ERROR: setup.guess.staticparameterbasis '...
                    'must have the same number of columns as setup.bounds.parameter']);
                end
           else
                % error parameter not numeric
                error(['GPOPS-II ERROR: setup.guess.staticparameterbasis '...
                  'must be numeric']);
           end
        else
          % error parameter guess provided when parameter is empty
          error(['GPOPS-II ERROR: setup.guess.staticparameterbasis '...
            'required because setup.bounds.parameter was provided, nlp is ''snopt'' ' ...
            'and warmstart is on']);
        end
        % store setup.bounds.parameter
        setup.guess.staticparameterbasis = usersetup.guess.staticparameterbasis;

        % remove field 'usersetup.guess.staticparameterbasis'
        usersetup.guess = rmfield(usersetup.guess,'staticparameterbasis'); 

    end 
    
  else
    if isfield(usersetup.guess,'parameter');
      % error parameter guess provided when parameter is empty
      NumConflicts = NumConflicts + 1;
      ConflictsStr{NumConflicts} = (['    setup.guess.parameter is being ignored '...
        'because setup.bounds.parameter is empty']);
    end
    if isfield(usersetup.guess,'staticparametermultipliers');
      % error parameter guess provided when parameter is empty
      NumConflicts = NumConflicts + 1;
      ConflictsStr{NumConflicts} = (['    setup.guess.staticparametermultipliers is being ignored '...
        'because setup.bounds.parameter is empty']);
    end
    if isfield(usersetup.guess,'staticparameterbasis');
      % error parameter guess provided when parameter is empty
      NumConflicts = NumConflicts + 1;
      ConflictsStr{NumConflicts} = (['    setup.guess.staticparameterbasis is being ignored '...
        'because setup.bounds.parameter is empty']);
    end
  end
  % check usersetup.guess for unknown fields
  % valid fields are 'phase', 'basis', 'parameter','eventgroupmultipliers', 'eventgroupbasis','staticparametermultipliers'
  % 'staticparameterbasis'
  URF = fieldnames(usersetup.guess);
  for URFcount = 1:size(URF,1);
    NumWarnings = NumWarnings + 1;
    WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.guess.',URF{URFcount}]);
  end
  
  % remove field 'usersetup.guess'
  usersetup = rmfield(usersetup,'guess');
else
  % error guess is not provided
  error('GPOPS-II ERROR: setup.guess is required');
end

if isfield(usersetup, 'derivatives');
  if ~isempty(usersetup.derivatives);
    if ~isstruct(usersetup.derivatives);
      error('GPOPS-II ERROR: setup.derivatives must be a structure');
    end
    if isfield(usersetup.derivatives, 'supplier');
      if ~isempty(usersetup.derivatives.supplier);
        % check for valid usersetup.derivatives.supplier
        if ischar(usersetup.derivatives.supplier);
          if strcmpi(usersetup.derivatives.supplier, 'sparseCD') || strcmpi(usersetup.derivatives.supplier, 'sparseFD') ||...
              strcmpi(usersetup.derivatives.supplier, 'sparseBD') || strcmpi(usersetup.derivatives.supplier, 'analytic') ||...
              strcmpi(usersetup.derivatives.supplier, 'adigator');
            setup.derivatives.supplier = usersetup.derivatives.supplier;
          else
            % error not valid supplier
            error(['GPOPS-II ERROR: Invalid option for setup.derivatives.supplier, valid '...
              'options are ''sparseCD'', ''sparseFD'', ''sparseBD'', ''analytic'', and ''adigator''']);
          end
        else
          % error if usersetup.derivatives.supplier is not a character string
          error('GPOPS-II ERROR: setup.derivatives.supplier must be a character string');
        end
      else
        % set defaults setup.derivatives.supplier
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.supplier = ''',defaults.derivatives.supplier,'''']);
        setup.derivatives.supplier = defaults.derivatives.supplier;
      end
      % remove field 'supplier'
      usersetup.derivatives = rmfield(usersetup.derivatives,'supplier');
    else
      % set defaults setup.derivatives.supplier
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.supplier = ''',defaults.derivatives.supplier,'''']);
      setup.derivatives.supplier = defaults.derivatives.supplier;
    end
    if isfield(usersetup.derivatives, 'derivativelevel');
      if ~isempty(usersetup.derivatives.derivativelevel);
        % check for valid usersetup.derivatives.derivativelevel
        if ischar(usersetup.derivatives.derivativelevel);
          if strcmpi(usersetup.derivatives.derivativelevel, 'first') || strcmpi(usersetup.derivatives.derivativelevel, 'second');
            setup.derivatives.derivativelevel = usersetup.derivatives.derivativelevel;
          else
            % error not valid derivativelevel
            error(['GPOPS-II ERROR: Invalid option for setup.derivatives.derivativelevel, valid '...
              'options are ''first'', and ''second''']);
          end
        else
          % error if usersetup.derivatives.supplier is not a character string
          error('GPOPS-II ERROR: setup.derivatives.derivativelevel must be a character string');
        end
        
        % check for valid usersetup.derivatives.derivativelevel
        if strcmpi(setup.nlp.solver,'snopt') && strcmpi(setup.derivatives.derivativelevel, 'second');
          % snopt is first derivative method only
          setup.derivatives.derivativelevel = 'first';
          % set defaults setup.derivatives.supplier
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = ('    Using default setting setup.derivatives.supplier = ''first'' because snopt uses first derivatives only');
        end
      else
        % set defaults setup.derivatives.derivativelevel
        if strcmpi(setup.nlp.solver,'snopt') && strcmpi(defaults.derivatives.derivativelevel, 'second');
          % snopt is first derivative method only
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = ('    Using default setting setup.derivatives.derivativelevel = ''first'' because snopt uses first derivatives only');
          setup.derivatives.derivativelevel = 'first';
        else
          % set defaults setup.derivatives.derivativelevel
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.derivativelevel = ''',defaults.derivatives.derivativelevel,'''']);
          setup.derivatives.derivativelevel = defaults.derivatives.derivativelevel;
        end
      end
      % remove field 'supplier'
      usersetup.derivatives = rmfield(usersetup.derivatives,'derivativelevel');
    else
      % set defaults setup.derivatives.derivativelevel
      if strcmpi(setup.nlp.solver,'snopt') && strcmpi(defaults.derivatives.derivativelevel, 'second');
        % snopt is first derivative method only
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = ('    Using default setting setup.derivatives.derivativelevel = ''first'' because snopt uses first derivatives only');
        setup.derivatives.derivativelevel = 'first';
      else
        % set defaults setup.derivatives.derivativelevel
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.derivativelevel = ''',defaults.derivatives.derivativelevel,'''']);
        setup.derivatives.derivativelevel = defaults.derivatives.derivativelevel;
      end
    end
    
    if strcmpi(setup.derivatives.supplier, 'analytic') || strcmpi(setup.derivatives.supplier, 'adigator');
      if isfield(usersetup.derivatives, 'dependencies');
        % ignore usersetup.derivatives.dependencies
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.derivatives.dependencies because '...
          'setup.derivatives.supplier = ''',setup.derivatives.supplier,'''']);
        usersetup.derivatives = rmfield(usersetup.derivatives,'dependencies');
      end
      if isfield(usersetup.derivatives, 'stepsize1');
        % ignore usersetup.derivatives.stepsize1
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.derivatives.stepsize1 because '...
          'setup.derivatives.supplier = ''',setup.derivatives.supplier,'''']);
        usersetup.derivatives = rmfield(usersetup.derivatives,'stepsize1');
      end
      if isfield(usersetup.derivatives, 'stepsize2');
        % ignore usersetup.derivatives.stepsize2
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.derivatives.stepsize2 because '...
          'setup.derivatives.supplier = ''',setup.derivatives.supplier,'''']);
        usersetup.derivatives = rmfield(usersetup.derivatives,'stepsize2');
      end
      if isfield(usersetup.derivatives, 'numsamples');
        % ignore usersetup.derivatives.numsamples
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.derivatives.numsamples because '...
          'setup.derivatives.supplier = ''',setup.derivatives.supplier,'''']);
        usersetup.derivatives = rmfield(usersetup.derivatives,'numsamples');
      end
    else
      % check for valid usersetup.derivatives.dependencies
      if isfield(usersetup.derivatives, 'dependencies');
        if ~isempty(usersetup.derivatives.dependencies);
          if ischar(usersetup.derivatives.dependencies);
            if strcmpi(usersetup.derivatives.dependencies, 'sparse') || strcmpi(usersetup.derivatives.dependencies, 'sparseNaN') ||...
                strcmpi(usersetup.derivatives.dependencies, 'full');
              setup.derivatives.dependencies = usersetup.derivatives.dependencies;
            else
              % error not valid dependencies
              error(['GPOPS-II ERROR: Invalid option for setup.derivatives.dependencies, valid '...
                'options are ''sparse'', ''sparseNaN'', and ''full''']);
            end
          else
            % error if usersetup.derivatives.dependencies is not a character string
            error('GPOPS-II ERROR: setup.derivatives.dependencies must be a character string');
          end
        else
          % set defaults setup.derivatives.dependencies
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.dependencies = ''',defaults.derivatives.supplier,'''']);
          setup.derivatives.dependencies = defaults.derivatives.dependencies;
        end
        % remove field 'dependencies'
        usersetup.derivatives = rmfield(usersetup.derivatives,'dependencies');
      else
        % set defaults setup.derivatives.dependencies
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.dependencies = ''',defaults.derivatives.supplier,'''']);
        setup.derivatives.dependencies = defaults.derivatives.dependencies;
      end
      
      % check for valid usersetup.derivatives.stepsize1
      if isfield(usersetup.derivatives, 'stepsize1');
        if ~isempty(usersetup.derivatives.stepsize1);
          if isnumeric(usersetup.derivatives.stepsize1);
            if size(usersetup.derivatives.stepsize1,1) ~= 1 || size(usersetup.derivatives.stepsize1,2) ~= 1;
              % error if usersetup.derivatives.stepsize1 must be a scalar
              error('GPOPS-II ERROR: setup.derivatives.stepsize1 must be a scalar');
            end
            if usersetup.derivatives.stepsize1 <= 0;
              % error if usersetup.derivatives.stepsize1 is not numeric
              error('GPOPS-II ERROR: setup.derivatives.stepsize1 must be greater than zero');
            end
            setup.derivatives.stepsize1 = usersetup.derivatives.stepsize1;
          else
            % error if usersetup.derivatives.stepsize1 is not numeric
            error('GPOPS-II ERROR: setup.derivatives.stepsize1 must be a numeric value greater than zero');
          end
        else
          % set defaults setup.derivatives.stepsize1
          if strcmpi(setup.derivatives.supplier, 'sparseCD');
            setup.derivatives.stepsize1 = defaults.stepsize1.sparseCD;
          elseif strcmpi(setup.derivatives.supplier, 'sparseFD');
            setup.derivatives.stepsize1 = defaults.stepsize1.sparseFD;
          elseif strcmpi(setup.derivatives.supplier, 'sparseBD');
            setup.derivatives.stepsize1 = defaults.stepsize1.sparseBD;
          end
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.stepsize1 = ',num2str(setup.derivatives.stepsize1)]);
        end
        % remove field 'stepsize1'
        usersetup.derivatives = rmfield(usersetup.derivatives,'stepsize1');
      else
        % set defaults setup.derivatives.stepsize1
        if strcmpi(setup.derivatives.supplier, 'sparseCD');
          setup.derivatives.stepsize1 = defaults.stepsize1.sparseCD;
        elseif strcmpi(setup.derivatives.supplier, 'sparseFD');
          setup.derivatives.stepsize1 = defaults.stepsize1.sparseFD;
        elseif strcmpi(setup.derivatives.supplier, 'sparseBD');
          setup.derivatives.stepsize1 = defaults.stepsize1.sparseBD;
        end
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.stepsize1 = ',num2str(setup.derivatives.stepsize1)]);
      end
      
      % check for valid usersetup.derivatives.stepsize2
      if strcmpi(setup.derivatives.derivativelevel, 'second');
        if isfield(usersetup.derivatives, 'stepsize2');
          if ~isempty(usersetup.derivatives.stepsize2);
            if isnumeric(usersetup.derivatives.stepsize2);
              if size(usersetup.derivatives.stepsize2,1) ~= 1 || size(usersetup.derivatives.stepsize2,2) ~= 1;
                % error if usersetup.derivatives.stepsize2 must be a scalar
                error('GPOPS-II ERROR: setup.derivatives.stepsize2 must be a scalar');
              end
              if usersetup.derivatives.stepsize2 <= 0;
                % error if usersetup.derivatives.stepsize2 is not numeric
                error('GPOPS-II ERROR: setup.derivatives.stepsize2 must be greater than zero');
              end
              setup.derivatives.stepsize2 = usersetup.derivatives.stepsize2;
            else
              % error if usersetup.derivatives.stepsize2 is not numeric
              error('GPOPS-II ERROR: setup.derivatives.stepsize2 must be a numeric value greater than zero');
            end
          else
            % set defaults setup.derivatives.stepsize2
            if strcmpi(setup.derivatives.supplier, 'sparseCD');
              setup.derivatives.stepsize2 = defaults.stepsize2.sparseCD;
            elseif strcmpi(setup.derivatives.supplier, 'sparseFD');
              setup.derivatives.stepsize2 = defaults.stepsize2.sparseFD;
            elseif strcmpi(setup.derivatives.supplier, 'sparseBD');
              setup.derivatives.stepsize2 = defaults.stepsize2.sparseBD;
            end
            NumDefaults = NumDefaults + 1;
            DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.stepsize2 = ',num2str(setup.derivatives.stepsize2)]);
          end
          % remove field 'stepsize2'
          usersetup.derivatives = rmfield(usersetup.derivatives,'stepsize2');
        else
          % set defaults setup.derivatives.stepsize2
          if strcmpi(setup.derivatives.supplier, 'sparseCD');
            setup.derivatives.stepsize2 = defaults.stepsize2.sparseCD;
          elseif strcmpi(setup.derivatives.supplier, 'sparseFD');
            setup.derivatives.stepsize2 = defaults.stepsize2.sparseFD;
          elseif strcmpi(setup.derivatives.supplier, 'sparseBD');
            setup.derivatives.stepsize2 = defaults.stepsize2.sparseBD;
          end
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.stepsize2 = ',num2str(setup.derivatives.stepsize2)]);
        end
      else
        if isfield(usersetup.derivatives, 'stepsize2');
          % ignore usersetup.derivatives.stepsize2
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    Ignoring setup.derivatives.stepsize2 because '...
            'setup.derivatives.derivativelevel = ''',setup.derivatives.derivativelevel,'''']);
          usersetup.derivatives = rmfield(usersetup.derivatives,'stepsize2');
        end
      end
      
      % check for valid usersetup.derivatives.numsamples
      if strcmpi(setup.derivatives.dependencies, 'sparse');
        if isfield(setup.derivatives, 'numsamples');
          if ~isempty(usersetup.derivatives.numsamples);
            if isnumeric(usersetup.derivatives.numsamples);
              if size(usersetup.derivatives.numsamples,1) ~= 1 || size(usersetup.derivatives.numsamples,2) ~= 1;
                % error if usersetup.derivatives.numsamples must be a scalar
                error('GPOPS-II ERROR: setup.derivatives.numsamples must be a scalar');
              end
              if ~(usersetup.derivatives.numsamples > 0 && (floor(usersetup.derivatives.numsamples) == ceil(usersetup.derivatives.numsamples)));
                % error if usersetup.derivatives.numsamples is not numeric
                error('GPOPS-II ERROR: setup.derivatives.numsamples must be an integer greater than zero');
              end
              setup.derivatives.numsamples = usersetup.derivatives.numsamples;
            else
              % error if usersetup.derivatives.numsamples is not numeric
              error('GPOPS-II ERROR: setup.derivatives.numsamples must be an integer greater than zero');
            end
          else
            % set defaults setup.derivatives.numsamples
            NumDefaults = NumDefaults + 1;
            DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.numsamples = ',num2str(defaults.derivatives.numsamples)]);
            setup.derivatives.numsamples = defaults.derivatives.numsamples;
          end
          % remove field 'numsamples'
          usersetup.derivatives = rmfield(usersetup.derivatives,'numsamples');
        else
          % set defaults setup.derivatives.numsamples
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.numsamples = ',num2str(defaults.derivatives.numsamples)]);
          setup.derivatives.numsamples = defaults.derivatives.numsamples;
        end
      else
        if isfield(setup.derivatives, 'numsamples');
          % ignore usersetup.derivatives.numsamples
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    Ignoring setup.derivatives.numsamples because '...
            'setup.derivatives.dependencies = ''',setup.derivatives.dependencies,'''']);
          usersetup.derivatives = rmfield(usersetup.derivatives,'stepsize2');
        end
      end
    end
    % check usersetup.guess for unknown fields
    % valid fields are 'phase', 'parameter'
    URF = fieldnames(usersetup.derivatives);
    for URFcount = 1:size(URF,1);
      NumWarnings = NumWarnings + 1;
      WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.derivatives.',URF{URFcount}]);
    end
  else
    % set defaults setup.derivatives
    % set defaults setup.derivatives.supplier
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.supplier = ''',defaults.derivatives.supplier,'''']);
    setup.derivatives.supplier = defaults.derivatives.supplier;
    
    % set defaults setup.derivatives.derivativelevel
    if strcmpi(setup.nlp.solver,'snopt') && strcmpi(defaults.derivatives.derivativelevel, 'second');
      % snopt is first derivative method only
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = ('    Using default setting setup.derivatives.derivativelevel = ''first'' because snopt uses first derivatives only');
      setup.derivatives.derivativelevel = 'first';
    else
      % set defaults setup.derivatives.derivativelevel
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.derivativelevel = ''',defaults.derivatives.derivativelevel,'''']);
      setup.derivatives.derivativelevel = defaults.derivatives.derivativelevel;
    end
    
    if ~(strcmpi(setup.derivatives.supplier, 'analytic') || strcmpi(setup.derivatives.supplier, 'adigator'));
      % set defaults setup.derivatives.dependencies
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.dependencies = ''',defaults.derivatives.supplier,'''']);
      setup.derivatives.dependencies = defaults.derivatives.dependencies;
      
      % set defaults setup.derivatives.stepsize1
      if strcmpi(setup.derivatives.supplier, 'sparseCD');
        setup.derivatives.stepsize1 = defaults.stepsize1.sparseCD;
      elseif strcmpi(setup.derivatives.supplier, 'sparseFD');
        setup.derivatives.stepsize1 = defaults.stepsize1.sparseFD;
      elseif strcmpi(setup.derivatives.supplier, 'sparseBD');
        setup.derivatives.stepsize1 = defaults.stepsize1.sparseBD;
      end
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.stepsize1 = ',num2str(setup.derivatives.stepsize1)]);
      
      if strcmpi(setup.derivatives.derivativelevel, 'second');
        % set defaults setup.derivatives.stepsize2
        if strcmpi(setup.derivatives.supplier, 'sparseCD');
          setup.derivatives.stepsize2 = defaults.stepsize2.sparseCD;
        elseif strcmpi(setup.derivatives.supplier, 'sparseFD');
          setup.derivatives.stepsize2 = defaults.stepsize2.sparseFD;
        elseif strcmpi(setup.derivatives.supplier, 'sparseBD');
          setup.derivatives.stepsize2 = defaults.stepsize2.sparseBD;
        end
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.stepsize2 = ',num2str(setup.derivatives.stepsize2)]);
      end
      
      if strcmpi(setup.derivatives.dependencies, 'sparse');
        % set defaults setup.derivatives.numsamples
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.numsamples = ',num2str(defaults.derivatives.numsamples)]);
        setup.derivatives.numsamples = defaults.derivatives.numsamples;
      end
    end
  end
  
  % remove field 'usersetup.derivatives'
  usersetup = rmfield(usersetup,'derivatives');
else
  % set defaults setup.derivatives
  % set defaults setup.derivatives.supplier
  NumDefaults = NumDefaults + 1;
  DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.supplier = ''',defaults.derivatives.supplier,'''']);
  setup.derivatives.supplier = defaults.derivatives.supplier;
  
  % set defaults setup.derivatives.derivativelevel
  if strcmpi(setup.nlp.solver,'snopt') && strcmpi(defaults.derivatives.derivativelevel, 'second');
    % snopt is first derivative method only
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = ('    Using default setting setup.derivatives.derivativelevel = ''first'' because snopt uses first derivatives only');
    setup.derivatives.derivativelevel = 'first';
  else
    % set defaults setup.derivatives.derivativelevel
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.derivativelevel = ''',defaults.derivatives.derivativelevel,'''']);
    setup.derivatives.derivativelevel = defaults.derivatives.derivativelevel;
  end
  
  if ~(strcmpi(setup.derivatives.supplier, 'analytic') || strcmpi(setup.derivatives.supplier, 'adigator'));
    % set defaults setup.derivatives.dependencies
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.dependencies = ''',defaults.derivatives.supplier,'''']);
    setup.derivatives.dependencies = defaults.derivatives.dependencies;
    
    % set defaults setup.derivatives.stepsize1
    if strcmpi(setup.derivatives.supplier, 'sparseCD');
      setup.derivatives.stepsize1 = defaults.stepsize1.sparseCD;
    elseif strcmpi(setup.derivatives.supplier, 'sparseFD');
      setup.derivatives.stepsize1 = defaults.stepsize1.sparseFD;
    elseif strcmpi(setup.derivatives.supplier, 'sparseBD');
      setup.derivatives.stepsize1 = defaults.stepsize1.sparseBD;
    end
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.stepsize1 = ',num2str(setup.derivatives.stepsize1)]);
    
    if strcmpi(setup.derivatives.derivativelevel, 'second');
      % set defaults setup.derivatives.stepsize2
      if strcmpi(setup.derivatives.supplier, 'sparseCD');
        setup.derivatives.stepsize2 = defaults.stepsize2.sparseCD;
      elseif strcmpi(setup.derivatives.supplier, 'sparseFD');
        setup.derivatives.stepsize2 = defaults.stepsize2.sparseFD;
      elseif strcmpi(setup.derivatives.supplier, 'sparseBD');
        setup.derivatives.stepsize2 = defaults.stepsize2.sparseBD;
      end
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.stepsize2 = ',num2str(setup.derivatives.stepsize2)]);
    end
    
    if strcmpi(setup.derivatives.dependencies, 'sparse');
      % set defaults setup.derivatives.numsamples
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.derivatives.numsamples = ',num2str(defaults.derivatives.numsamples)]);
      setup.derivatives.numsamples = defaults.derivatives.numsamples;
    end
  end
end

% check user scaling setup
if isfield(usersetup, 'scales');
  if ~isempty(usersetup.scales);
    if ~isstruct(usersetup.scales);
      error('GPOPS-II ERROR: setup.scales must be a structure');
    end
    %check for scale method
    if isfield(usersetup.scales, 'method');
      if ~isempty(usersetup.scales.method);
        if ischar(usersetup.scales.method);
          if ~(strcmpi(usersetup.scales.method, 'automatic-bounds') || ...
              strcmpi(usersetup.scales.method, 'automatic-guess') || ...
              strcmpi(usersetup.scales.method, 'automatic-guessUpdate') || ...
              strcmpi(usersetup.scales.method, 'automatic-hybrid') || ...
              strcmpi(usersetup.scales.method, 'automatic-hybridUpdate') || ...
              strcmpi(usersetup.scales.method, 'defined') || ...
              strcmpi(usersetup.scales.method, 'none'));
            % error not valid scales.method
            error(['GPOPS-II ERROR: Invalid option for setup.scales.method, valid '...
              'options are ''automatic-bounds'', ''automatic-guess'', ''defined'' or ''none''']);
          end
          setup.scales.method = usersetup.scales.method;
        else
          % error if usersetup.mesh.method is not a character string
          error('GPOPS-II ERROR: setup.scales.method must be a character string');
        end
      else
        % set default setup.scales.method
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.scales.method = ',defaults.scales.method]);
        setup.scales.method = defaults.scales.method;
      end
      % remove field 'method'
      usersetup.scales = rmfield(usersetup.scales,'method');
    else
      % set default setup.scales.method
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.scales.method = ',defaults.scales.method]);
      setup.scales.method = defaults.scales.method;
    end
    % ignore all other fields if usersetup.scales.method = 'none'
    if strcmpi(setup.scales.method, 'none') || strcmpi(setup.scales.method, 'defined');
      if isfield(usersetup.scales, 'numsamples');
        % ignore setup.scales.numsamples
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.scales.numsamples because '...
          'setup.scales.method = ''',setup.scales.method,'''']);
        usersetup.scales = rmfield(usersetup.scales,'numsamples');
      end
    else
      % check scales.numsamples
      if isfield(usersetup.scales, 'numsamples');
        if ~isempty(usersetup.scales.numsamples);
          if isnumeric(usersetup.scales.numsamples)
            if size(usersetup.scales.numsamples,1) ~= 1 || size(usersetup.scales.numsamples,2) ~= 1;
              % error if usersetup.scales.numsamples is not a scalar
              error('GPOPS-II ERROR: setup.scales.numsamples must be a scalar');
            end
            if floor(usersetup.scales.numsamples) ~= ceil(usersetup.scales.numsamples);
              % error if usersetup.scales.numsamples is must a
              % integer
              error('GPOPS-II ERROR: setup.scales.numsamples must be a integer');
            end
            if usersetup.scales.numsamples < 2;
              % error if usersetup.scales.numsamples is must be greater
              % or equal to 1
              error('GPOPS-II ERROR: setup.scales.numsamples must be greater than or equal to 2');
            end
            setup.scales.numsamples = usersetup.scales.numsamples;
          else
            % error if usersetup.scales.numsamples is not a numeric value
            error('GPOPS-II ERROR: setup.scales.numsamples must be numeric');
          end
        else
          % set default setup.scales.numsamples
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.scales.numsamples = ',num2str(defaults.scales.numsamples)]);
          setup.scales.numsamples = defaults.scales.numsamples;
        end
        % remove field 'numsamples'
        usersetup.scales = rmfield(usersetup.scales,'numsamples');
      else
        % set default setup.scales.numsamples
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.scales.numsamples = ',num2str(defaults.scales.numsamples)]);
        setup.scales.numsamples = defaults.scales.numsamples;
      end
    end
    
    % check defined scales
    if strcmpi(setup.scales.method, 'defined');
      % check scales.phase
      if isfield(usersetup.scales,'phase');
        % store usersetup.scales.phase
        setup.scales.phase = usersetup.scales.phase;
        
        % check that phases in a single dimension
        scalesphases = length(usersetup.scales.phase);
        if scalesphases ~= numel(usersetup.scales.phase);
          % error phase not single dimension is not provided
          error('GPOPS-II ERROR: setup.scales.phase must be a single dimension ');
        end
        
        % check if number of phases is the same
        if size(usersetup.scales.phase,2) ~= numphase;
          % size of phase sctructure is different
          error(['GPOPS-II ERROR: the scaling information must be provided for each '...
            'phase, setup.scales.phase needs to be the same size as setup.bounds.phase']);
        end
        
        % check for statescale
        if ~isfield(usersetup.scales.phase,'statescale');
          % error statescale is not provided
          error(['GPOPS-II ERROR: setup.scales.phase.statescale '...
            'is required when using setup.scales.method = ''defined''']);
        end
        % check stateshift
        if ~isfield(usersetup.scales.phase,'stateshift');
          % error stateshift is not provided
          error(['GPOPS-II ERROR: setup.scales.phase.stateshift '...
            'is required when using setup.scales.method = ''defined''']);
        end
        % check t0scale
        if ~isfield(usersetup.scales.phase,'t0scale');
          % error t0scale is not provided
          error(['GPOPS-II ERROR: setup.scales.phase.t0scale '...
            'is required when using setup.scales.method = ''defined''']);
        end
        % check t0shift
        if ~isfield(usersetup.scales.phase,'t0shift');
          % error t0shift is not provided
          error(['GPOPS-II ERROR: setup.scales.phase.t0shift '...
            'is required when using setup.scales.method = ''defined''']);
        end
        % check tfscale
        if ~isfield(usersetup.scales.phase,'tfscale');
          % error tfscale is not provided
          error(['GPOPS-II ERROR: setup.scales.phase.tfscale '...
            'is required when using setup.scales.method = ''defined''']);
        end
        % check tfshift
        if ~isfield(usersetup.scales.phase,'tfshift');
          % error tfshift is not provided
          error(['GPOPS-II ERROR: setup.scales.phase.tfshift '...
            'is required when using setup.scales.method = ''defined''']);
        end
        % check dynamicsconscale
        if ~isfield(usersetup.scales.phase,'dynamicsconscale');
          % error dynamicsconscale is not provided
          error(['GPOPS-II ERROR: setup.scales.phase.dynamicsconscale '...
            'is required when using setup.scales.method = ''defined''']);
        end
        % check controlscale
        if ~isfield(usersetup.scales.phase,'controlscale');
          usersetup.scales.phase(numphase).controlscale = [];
        end
        % check controlscale
        if ~isfield(usersetup.scales.phase,'controlshift');
          usersetup.scales.phase(numphase).controlshift = [];
        end
        % check integralscale
        if ~isfield(usersetup.scales.phase,'integralscale');
          usersetup.scales.phase(numphase).integralscale = [];
        end
        % check integralshift
        if ~isfield(usersetup.scales.phase,'integralshift');
          usersetup.scales.phase(numphase).integralshift = [];
        end
        % check integrandconscale
        if ~isfield(usersetup.scales.phase,'integrandconscale');
          usersetup.scales.phase(numphase).integrandconscale = [];
        end
        % check pathconscale
        if ~isfield(usersetup.scales.phase,'pathconscale');
          usersetup.scales.phase(numphase).pathconscale = [];
        end
        
        % get scales in each phase
        for phasecount = 1:numphase;
          % check statescale for each phase
          if isnumeric(usersetup.scales.phase(phasecount).statescale);
            if size(usersetup.scales.phase(phasecount).statescale,2) ~= numstate(phasecount)...
                || size(usersetup.scales.phase(phasecount).statescale,1) ~= 1;
              % error statescale must be a row vector
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').statescale '...
                'must be a row vector with the same number of columns as setup.bounds.phase(',num2str(phasecount),').state']);
            end
            if any(usersetup.scales.phase(phasecount).statescale <= 0);
              % error statescale values must be positive
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').statescale '...
                'must contain positive values']);
            end
          else
            % error statescale not numeric
            error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').statescale '...
              'must be numeric']);
          end
          % check stateshift for each phase
          if isnumeric(usersetup.scales.phase(phasecount).stateshift);
            if size(usersetup.scales.phase(phasecount).stateshift,2) ~= numstate(phasecount)...
                || size(usersetup.scales.phase(phasecount).stateshift,1) ~= 1;
              % error stateshift must be a row vector
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').stateshift '...
                'must be a row vector with the same number of columns as setup.bounds.phase(',num2str(phasecount),').state']);
            end
          else
            % error stateshift not numeric
            error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').stateshift '...
              'must be numeric']);
          end
          % check dynamicsconscale for each phase
          if isnumeric(usersetup.scales.phase(phasecount).dynamicsconscale);
            if size(usersetup.scales.phase(phasecount).dynamicsconscale,2) ~= numstate(phasecount)...
                || size(usersetup.scales.phase(phasecount).dynamicsconscale,1) ~= 1;
              % error dynamicsconscale must be a row vector
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').dynamicsconscale '...
                'must be a row vector with the same number of columns as setup.bounds.phase(',num2str(phasecount),').state']);
            end
            if any(usersetup.scales.phase(phasecount).dynamicsconscale <= 0);
              % error dynamicsconscale values must be positive
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').dynamicsconscale '...
                'must contain positive values']);
            end
          else
            % error dynamicsconscale not numeric
            error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').dynamicsconscale '...
              'must be numeric']);
          end
          % check t0scale for each phase
          if isnumeric(usersetup.scales.phase(phasecount).t0scale);
            if size(usersetup.scales.phase(phasecount).t0scale,2) ~= 1 ...
                || size(usersetup.scales.phase(phasecount).t0scale,1) ~= 1;
              % error t0scale must be a row vector
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').t0scale '...
                'must be a scalar']);
            end
            if any(usersetup.scales.phase(phasecount).t0scale <= 0);
              % error t0scale values must be positive
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').t0scale '...
                'must contain a positive value']);
            end
          else
            % error t0scale not numeric
            error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').t0scale '...
              'must be numeric']);
          end
          % check t0shift for each phase
          if isnumeric(usersetup.scales.phase(phasecount).t0shift);
            if size(usersetup.scales.phase(phasecount).t0shift,2) ~= 1 ...
                || size(usersetup.scales.phase(phasecount).t0shift,1) ~= 1;
              % error t0shift must be a row vector
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').t0shift '...
                'must be a scalar']);
            end
          else
            % error t0shift not numeric
            error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').t0shift '...
              'must be numeric']);
          end
          % check tfscale for each phase
          if isnumeric(usersetup.scales.phase(phasecount).tfscale);
            if size(usersetup.scales.phase(phasecount).tfscale,2) ~= 1 ...
                || size(usersetup.scales.phase(phasecount).tfscale,1) ~= 1;
              % error tfscale must be a row vector
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').tfscale '...
                'must be a scalar']);
            end
            if any(usersetup.scales.phase(phasecount).tfscale <= 0);
              % error tfscale values must be positive
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').tfscale '...
                'must contain a positive value']);
            end
          else
            % error tfscale not numeric
            error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').tfscale '...
              'must be numeric']);
          end
          % check tfshift for each phase
          if isnumeric(usersetup.scales.phase(phasecount).tfshift);
            if size(usersetup.scales.phase(phasecount).tfshift,2) ~= 1 ...
                || size(usersetup.scales.phase(phasecount).tfshift,1) ~= 1;
              % error tfshift must be a row vector
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').tfshift '...
                'must be a scalar']);
            end
          else
            % error tfshift not numeric
            error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').tfshift '...
              'must be numeric']);
          end
          % check controlscale and controlshift for each phase
          if numcontrol(phasecount) > 0;
            % check controlscale in each phase
            if isnumeric(usersetup.scales.phase(phasecount).controlscale);
              if size(usersetup.scales.phase(phasecount).controlscale,2) ~= numcontrol(phasecount)...
                  || size(usersetup.scales.phase(phasecount).controlscale,1) ~= 1;
                % error controlscale must be a row vector
                error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').controlscale '...
                  'must be a row vector with the same number of columns as setup.bounds.phase(',num2str(phasecount),').control']);
              end
              if any(usersetup.scales.phase(phasecount).controlscale <= 0);
                % error controlscale values must be positive
                error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').controlscale '...
                  'must contain positive values']);
              end
            else
              % error control not numeric
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').controlscale '...
                'must be numeric']);
            end
            % check controlshift for each phase
            if isnumeric(usersetup.scales.phase(phasecount).controlshift);
              if size(usersetup.scales.phase(phasecount).controlshift,2) ~= numcontrol(phasecount)...
                  || size(usersetup.scales.phase(phasecount).controlshift,1) ~= 1;
                % error controlshift must be a row vector
                error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').controlshift '...
                  'must be a row vector with the same number of columns as setup.bounds.phase(',num2str(phasecount),').control']);
              end
            else
              % error control not numeric
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').controlshift '...
                'must be numeric']);
            end
          end
          
          % check integralscale, integralshift, and integrandconscale for each phase
          if numintegral(phasecount) > 0;
            % check integralscale in each phase
            if isnumeric(usersetup.scales.phase(phasecount).integralscale);
              if size(usersetup.scales.phase(phasecount).integralscale,2) ~= numintegral(phasecount)...
                  || size(usersetup.scales.phase(phasecount).integralscale,1) ~= 1;
                % error integralscale must be a row vector
                error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').integralscale '...
                  'must be a row vector with the same number of columns as setup.bounds.phase(',num2str(phasecount),').integral']);
              end
              if any(usersetup.scales.phase(phasecount).integralscale <= 0);
                % error integralscale values must be positive
                error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').integralscale '...
                  'must contain positive values']);
              end
            else
              % error integral not numeric
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').integralscale '...
                'must be numeric']);
            end
            % check integralshift for each phase
            if isnumeric(usersetup.scales.phase(phasecount).integralshift);
              if size(usersetup.scales.phase(phasecount).integralshift,2) ~= numintegral(phasecount)...
                  || size(usersetup.scales.phase(phasecount).integralshift,1) ~= 1;
                % error integralshift must be a row vector
                error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').integralshift '...
                  'must be a row vector with the same number of columns as setup.bounds.phase(',num2str(phasecount),').integral']);
              end
            else
              % error integral not numeric
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').integralshift '...
                'must be numeric']);
            end
            % check integrandconscale in each phase
            if isnumeric(usersetup.scales.phase(phasecount).integrandconscale);
              if size(usersetup.scales.phase(phasecount).integrandconscale,2) ~= numintegral(phasecount)...
                  || size(usersetup.scales.phase(phasecount).integrandconscale,1) ~= 1;
                % error integrandconscale must be a row vector
                error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').integrandconscale '...
                  'must be a row vector with the same number of columns as setup.bounds.phase(',num2str(phasecount),').integral']);
              end
              if any(usersetup.scales.phase(phasecount).integrandconscale <= 0);
                % error integrandconscale values must be positive
                error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').integrandconscale '...
                  'must contain positive values']);
              end
            else
              % error integral not numeric
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').integrandconscale '...
                'must be numeric']);
            end
          end
          % check pathconscale for each phase
          if numpath(phasecount) > 0;
            % check pathconscale in each phase
            if isnumeric(usersetup.scales.phase(phasecount).pathconscale);
              if size(usersetup.scales.phase(phasecount).pathconscale,2) ~= numpath(phasecount)...
                  || size(usersetup.scales.phase(phasecount).pathconscale,1) ~= 1;
                % error pathconscale must be a row vector
                error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').pathconscale '...
                  'must be a row vector with the same number of columns as setup.bounds.phase(',num2str(phasecount),').path']);
              end
              if any(usersetup.scales.phase(phasecount).pathconscale <= 0);
                % error pathconscale values must be positive
                error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').pathconscale '...
                  'must contain positive values']);
              end
            else
              % error pathconscale not numeric
              error(['GPOPS-II ERROR: setup.scales.phase(',num2str(phasecount),').pathconscale '...
                'must be numeric']);
            end
          end
        end
        
        % remove field 'phase'
        usersetup.scales = rmfield(usersetup.scales,'phase');
      else
        % error scales.phase is required when using defined
        error(['GPOPS-II ERROR: the scaling information for each phase is required to be provided '...
          'in setup.scales.phase']);
      end
      
      % check objscale
      if isfield(usersetup.scales,'objscale');
        if isnumeric(usersetup.scales.objscale);
          if size(usersetup.scales.objscale,2) ~= 1 ...
              || size(usersetup.scales.objscale,1) ~= 1;
            % error objscale must be a scalar
            error('GPOPS-II ERROR: setup.scales.objscale must be a scalar');
          end
          if any(usersetup.scales.objscale <= 0);
            % error objscale values must be positive
            error('GPOPS-II ERROR: setup.scales.objscale must contain a positive value');
          end
        else
          % error objscale not numeric
          error('GPOPS-II ERROR: setup.scales.objscale must be numeric');
        end
        % store objscale
        setup.scales.objscale = usersetup.scales.objscale;
        
        % remove field 'objscale'
        usersetup.scales = rmfield(usersetup.scales,'objscale');
      else
        % error scales.objscale is required when using defined
        error(['GPOPS-II ERROR: setup.scales.objscale '...
          'is required when using setup.scales.method = ''defined''']);
      end
      
      % check parameterscale and parametershift
      if numparameter ~= 0;
        % check parameterscale
        if isfield(usersetup.scales,'parameterscale');
          if isnumeric(usersetup.scales.parameterscale);
            if size(usersetup.scales.parameterscale,2) ~= numparameter ...
                || size(usersetup.scales.parameterscale,1) ~= 1;
              % error parameterscale must be a row vector
              error(['GPOPS-II ERROR: setup.scales.parameterscale '...
                'must be a row vector with the same number of columns as setup.bounds.parameter']);
            end
            if any(usersetup.scales.parameterscale <= 0);
              % error parameterscale values must be positive
              error('GPOPS-II ERROR: setup.scales.parameterscale must contain positive values');
            end
          else
            % error parameterscale not numeric
            error('GPOPS-II ERROR: setup.scales.parameterscale must be numeric');
          end
          % store parameterscale
          setup.scales.parameterscale = usersetup.scales.parameterscale;
          
          % remove field 'parameterscale'
          usersetup.scales = rmfield(usersetup.scales,'parameterscale');
        else
          % error scales.parameterscale is required when using defined
          error(['GPOPS-II ERROR: setup.scales.parameterscale '...
            'is required when using setup.scales.method = ''defined''']);
        end
        % check parametershift
        if isfield(usersetup.scales,'parametershift');
          if isnumeric(usersetup.scales.parametershift);
            if size(usersetup.scales.parametershift,2) ~= numparameter ...
                || size(usersetup.scales.parametershift,1) ~= 1;
              % error parametershift must be a row vector
              error(['GPOPS-II ERROR: setup.scales.parametershift '...
                'must be a row vector with the same number of columns as setup.bounds.parameter']);
            end
          else
            % error parametershift not numeric
            error('GPOPS-II ERROR: setup.scales.parametershift must be numeric');
          end
          % store parametershift
          setup.scales.parametershift = usersetup.scales.parametershift;
          
          % remove field 'parametershift'
          usersetup.scales = rmfield(usersetup.scales,'parametershift');
        else
          % error scales.parametershift is required when using defined
          error(['GPOPS-II ERROR: setup.scales.parametershift '...
            'is required when using setup.scales.method = ''defined''']);
        end
      end      
      
      % check eventscales
      if numeventgroup ~= 0;
        if isfield(usersetup.scales,'eventgroup');
          % get number of eventgroups
          scaleseventgroup = length(usersetup.scales.eventgroup);
          
          % check that eventgroup in a single dimension
          if scaleseventgroup ~= numel(usersetup.scales.eventgroup);
            % error phase not single dimension
            error('GPOPS-II ERROR: setup.scales.eventgroup must be a single dimension ');
          end
          
          % check if number of phases is the same
          if scaleseventgroup ~= numeventgroup;
            % size of phase sctructure is different
            error(['GPOPS-II ERROR: the scaling information must be provided for each '...
              'phase, setup.scales.phase needs to be the same size as setup.bounds.phase']);
          end
          
          % check scales.eventgroup.eventconscale
          if ~isfield(usersetup.scales.eventgroup,'eventconscale');
            % error eventconscale is not provided
            error(['GPOPS-II ERROR: setup.scales.eventgroup.eventconscale '...
              'is required when using setup.scales.method = ''defined''']);
          end
          
          % check eventconscale for each eventgroup
          for eventgroupcount = 1:numeventgroup;
            % check eventconscale for each eventgroup
            if numevent(eventgroupcount) > 0;
              if isnumeric(usersetup.scales.eventgroup(eventgroupcount).eventconscale);
                if size(usersetup.scales.eventgroup(eventgroupcount).eventconscale,2) ~= numevent(eventgroupcount)...
                    || size(usersetup.scales.eventgroup(eventgroupcount).eventconscale,1) ~= 1;
                  % error eventconscale must be a row vector
                  error(['GPOPS-II ERROR: setup.scales.eventgroup(',num2str(eventgroupcount),').eventconscale '...
                    'must be a row vector with the same number of columns as setup.bounds.eventgroup(',num2str(eventgroupcount),')']);
                end
                if any(usersetup.scales.eventgroup(eventgroupcount).eventconscale) <= 0;
                  % error pathconscale values must be positive
                  error(['GPOPS-II ERROR: setup.scales.eventgroup(',num2str(eventgroupcount),').eventconscale '...
                    'must contain positive values']);
                end
              else
                % error eventconscale not numeric
                error(['GPOPS-II ERROR: setup.scales.eventgroup(',num2str(eventgroupcount),').eventconscale '...
                  'must be numeric']);
              end
            end
          end
          % store eventgroup
          setup.scales.eventgroup = usersetup.scales.eventgroup;
          
          % remove field 'eventgroup'
          usersetup.scales = rmfield(usersetup.scales,'eventgroup');
        else
          % error scales.eventgroup is required when using defined
          error(['GPOPS-II ERROR: the scaling information for each eventgroup is required to be provided '...
            'in setup.scales.eventgroup']);
        end
      end
      
    end
    
    % check usersetup.scales for unknown fields
    % valid fields are 'method', 'numsamples'
    URF = fieldnames(usersetup.scales);
    for URFcount = 1:size(URF,1);
      NumWarnings = NumWarnings + 1;
      WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.scales.',URF{URFcount}]);
    end
  else
    % set default setup.scales.method
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.scales.method = ',num2str(defaults.scales.method)]);
    setup.scales.method = defaults.scales.method;
    
    if ~strcmpi(setup.scales.method, 'none');
      % set default setup.scales.numsamples
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.scales.numsamples = ',num2str(defaults.scales.numsamples)]);
      setup.scales.numsamples = defaults.scales.numsamples;
    end
  end
  
  % remove field 'usersetup.scales'
  usersetup = rmfield(usersetup,'scales');
else
  % set default setup.scales.method
  NumDefaults = NumDefaults + 1;
  DefaultStr{NumDefaults} = (['    Using default setting setup.scales.method = ',num2str(defaults.scales.method)]);
  setup.scales.method = defaults.scales.method;
  
  if ~strcmpi(setup.scales.method, 'none');
    % set default setup.scales.numsamples
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.scales.numsamples = ',num2str(defaults.scales.numsamples)]);
    setup.scales.numsamples = defaults.scales.numsamples;
  end
end

% check mesh
if isfield(usersetup, 'mesh');
  % check mesh.method
  if ~isempty(usersetup.mesh);
    if ~isstruct(usersetup.mesh);
      error('GPOPS-II ERROR: setup.mesh must be a structure');
    end
    if isfield(usersetup.mesh, 'method');
      if ~isempty(usersetup.mesh.method);
        if ischar(usersetup.mesh.method);
          if ~(strcmpi(usersetup.mesh.method, 'hp-PattersonRao') || ...
              strcmpi(usersetup.mesh.method, 'hp-DarbyRao') || ...
              strcmpi(usersetup.mesh.method, 'hp-LiuRao') || ...
              strcmpi(usersetup.mesh.method, 'hp-LiuRao-Legendre') || ...
              strcmpi(usersetup.mesh.method, 'none'));
            % error not valid mesh.method
            error(['GPOPS-II ERROR: Invalid option for setup.mesh.method, valid '...
              'options are ''hp-PattersonRao'', ''hp-DarbyRao'', ''hp-LiuRao'', ''hp-PattersonRao'', or ''none''']);
          end
          setup.mesh.method = usersetup.mesh.method;
        else
          % error if usersetup.mesh.method is not a character string
          error('GPOPS-II ERROR: setup.mesh.method must be a character string');
        end
      else
        % set default setup.mesh.method
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.method = ',defaults.mesh.method]);
        setup.mesh.method = defaults.mesh.method;
      end
      % remove field 'method'
      usersetup.mesh = rmfield(usersetup.mesh,'method');
    else
      % set default setup.mesh.method
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.method = ',defaults.mesh.method]);
      setup.mesh.method = defaults.mesh.method;
    end
    % ignore all other fields if usersetup.mesh.method = 'none'
    if strcmpi(setup.mesh.method, 'none');
      % ignore setup.mesh.tolerance
      if isfield(usersetup.mesh, 'tolerance');
        % ignore setup.mesh.tolerance
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.mesh.tolerance because '...
          'setup.mesh.method = ''',setup.mesh.method,'''']);
        usersetup.mesh = rmfield(usersetup.mesh,'tolerance');
      end
      % ignore setup.mesh.maxiterations
      if isfield(usersetup.mesh, 'maxiterations');
        % ignore setup.mesh.maxiterations
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.mesh.maxiterations because '...
          'setup.mesh.method = ''',setup.mesh.method,'''']);
        usersetup.mesh = rmfield(usersetup.mesh,'maxiterations');
      end
      % ignore setup.mesh.colpointsmin
      if isfield(usersetup.mesh, 'colpointsmin');
        % ignore setup.mesh.colpointsmin
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.mesh.colpointsmin because '...
          'setup.mesh.method = ''',setup.mesh.method,'''']);
        usersetup.mesh = rmfield(usersetup.mesh,'colpointsmin');
      end
      % ignore setup.mesh.colpointsmax
      if isfield(usersetup.mesh, 'colpointsmax');
        % ignore setup.mesh.colpointsmax
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.mesh.colpointsmax because '...
          'setup.mesh.method = ''',setup.mesh.method,'''']);
        usersetup.mesh = rmfield(usersetup.mesh,'colpointsmax');
      end
      % ignore setup.mesh.splitmult
      if isfield(usersetup.mesh, 'splitmult');
        % ignore setup.mesh.splitmult
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.mesh.splitmult because '...
          'setup.mesh.method = ''',setup.mesh.method,'''']);
        usersetup.mesh = rmfield(usersetup.mesh,'splitmult');
      end
      % ignore setup.mesh.curveratio
      if isfield(usersetup.mesh, 'curveratio');
        % ignore setup.mesh.curveratio
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.mesh.curveratio because '...
          'setup.mesh.method = ''',setup.mesh.method,'''']);
        usersetup.mesh = rmfield(usersetup.mesh,'curveratio');
      end
      % ignore setup.mesh.R
      if isfield(usersetup.mesh, 'R');
        % ignore setup.mesh.R
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    Ignoring setup.mesh.R because '...
          'setup.mesh.method = ''',setup.mesh.method,'''']);
        usersetup.mesh = rmfield(usersetup.mesh,'R');
      end
    else
      % check mesh.tolerance
      if isfield(usersetup.mesh, 'tolerance');
        if ~isempty(usersetup.mesh.tolerance);
          if isnumeric(usersetup.mesh.tolerance);
            if size(usersetup.mesh.tolerance,1) ~= 1 || size(usersetup.mesh.tolerance,2) ~= 1;
              % error if usersetup.mesh.tolerance is not a scalar
              error('GPOPS-II ERROR: setup.mesh.tolerance must be a scalar');
            end
            if usersetup.mesh.tolerance <= 0;
              % error if usersetup.mesh.tolerance is must be greater than zero
              error('GPOPS-II ERROR: setup.mesh.tolerance must be greater than zero');
            end
            setup.mesh.tolerance = usersetup.mesh.tolerance;
          else
            % error if usersetup.mesh.tolerance is not a numeric value
            error('GPOPS-II ERROR: setup.mesh.tolerance must be numeric');
          end
        else
          % set default setup.mesh.tolerance
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.tolerance = ',num2str(defaults.mesh.tolerance)]);
          setup.mesh.tolerance = defaults.mesh.tolerance;
        end
        % remove field 'tolerance'
        usersetup.mesh = rmfield(usersetup.mesh,'tolerance');
      else
        % set default setup.mesh.tolerance
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.tolerance = ',num2str(defaults.mesh.tolerance)]);
        setup.mesh.tolerance = defaults.mesh.tolerance;
      end
      
      % check mesh.maxiteration
      if isfield(usersetup.mesh, 'maxiterations');
        if ~isempty(usersetup.mesh.maxiterations);
          if isnumeric(usersetup.mesh.maxiterations);
            if size(usersetup.mesh.maxiterations,1) ~= 1 || size(usersetup.mesh.maxiterations,2) ~= 1;
              % error if usersetup.mesh.maxiterations is not a scalar
              error('GPOPS-II ERROR: setup.mesh.maxiterations must be a scalar');
            end
            if floor(usersetup.mesh.maxiterations) ~= ceil(usersetup.mesh.maxiterations);
              % error if usersetup.mesh.maxiterations is must a
              % integer
              error('GPOPS-II ERROR: setup.mesh.maxiterations must be a integer');
            end
            if usersetup.mesh.maxiterations < 0;
              % error if usersetup.mesh.maxiterations is must be greater
              % or equal to 0
              error('GPOPS-II ERROR: setup.mesh.maxiterations must be greater than or equal to zero');
            end
            setup.mesh.maxiterations = usersetup.mesh.maxiterations;
          else
            % error if usersetup.mesh.maxiterations is not a numeric value
            error('GPOPS-II ERROR: setup.mesh.maxiterations must be numeric');
          end
        else
          % set default setup.mesh.maxiterations
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.maxiterations = ',num2str(defaults.mesh.maxiterations)]);
          setup.mesh.maxiterations = defaults.mesh.maxiterations;
        end
        % remove field 'maxiterations'
        usersetup.mesh = rmfield(usersetup.mesh,'maxiterations');
      else
        % set default setup.mesh.maxiterations
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.maxiterations = ',num2str(defaults.mesh.maxiterations)]);
        setup.mesh.maxiterations = defaults.mesh.maxiterations;
      end
      
      % check mesh.colpointsmin
      if isfield(usersetup.mesh, 'colpointsmin');
        if ~isempty(usersetup.mesh.colpointsmin);
          if isnumeric(usersetup.mesh.colpointsmin);
            if size(usersetup.mesh.colpointsmin,1) ~= 1 || size(usersetup.mesh.colpointsmin,2) ~= 1;
              % error if usersetup.mesh.colpointsmin is not a scalar
              error('GPOPS-II ERROR: setup.mesh.colpointsmin must be a scalar');
            end
            if floor(usersetup.mesh.colpointsmin) ~= ceil(usersetup.mesh.colpointsmin);
              % error if usersetup.mesh.colpointsmin is must a
              % integer
              error('GPOPS-II ERROR: setup.mesh.colpointsmin must be a integer');
            end
            if usersetup.mesh.colpointsmin < 2;
              % error if usersetup.mesh.colpointsmin is must be greater
              % or equal to 1
              error('GPOPS-II ERROR: setup.mesh.colpointsmin must be greater than or equal to two');
            end
            setup.mesh.colpointsmin = usersetup.mesh.colpointsmin;
          else
            % error if usersetup.mesh.colpointsmin is not a numeric value
            error('GPOPS-II ERROR: setup.mesh.colpointsmin must be numeric');
          end
        else
          % set default setup.mesh.colpointsmin
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.colpointsmin = ',num2str(defaults.mesh.colpointsmin)]);
          setup.mesh.colpointsmin = defaults.mesh.colpointsmin;
        end
        % remove field 'colpointsmin'
        usersetup.mesh = rmfield(usersetup.mesh,'colpointsmin');
      else
        % set default setup.mesh.colpointsmin
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.colpointsmin = ',num2str(defaults.mesh.colpointsmin)]);
        setup.mesh.colpointsmin = defaults.mesh.colpointsmin;
      end
      
      % check mesh.colpointsmax
      if isfield(usersetup.mesh, 'colpointsmax');
        if ~isempty(usersetup.mesh.colpointsmax);
          if isnumeric(usersetup.mesh.colpointsmax);
            if size(usersetup.mesh.colpointsmax,1) ~= 1 || size(usersetup.mesh.colpointsmax,2) ~= 1;
              % error if usersetup.mesh.colpointsmax is not a scalar
              error('GPOPS-II ERROR: setup.mesh.colpointsmax must be a scalar');
            end
            if floor(usersetup.mesh.colpointsmax) ~= ceil(usersetup.mesh.colpointsmax);
              % error if usersetup.mesh.colpointsmax is must a
              % integer
              error('GPOPS-II ERROR: setup.mesh.colpointsmax must be a integer');
            end
            if usersetup.mesh.colpointsmax < 1;
              % error if usersetup.mesh.colpointsmax is must be greater
              % or equal to 1
              error('GPOPS-II ERROR: setup.mesh.colpointsmax must be greater than or equal to one');
            end
            setup.mesh.colpointsmax = usersetup.mesh.colpointsmax;
          else
            % error if usersetup.mesh.colpointsmax is not a numeric value
            error('GPOPS-II ERROR: setup.mesh.colpointsmax must be numeric');
          end
        else
          % set default setup.mesh.colpointsmax
          NumDefaults = NumDefaults + 1;
          DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.colpointsmax = ',num2str(defaults.mesh.colpointsmax)]);
          setup.mesh.colpointsmax = defaults.mesh.colpointsmax;
        end
        % remove field 'colpointsmax'
        usersetup.mesh = rmfield(usersetup.mesh,'colpointsmax');
      else
        % set default setup.mesh.colpointsmax
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.colpointsmax = ',num2str(defaults.mesh.colpointsmax)]);
        setup.mesh.colpointsmax = defaults.mesh.colpointsmax;
      end
      
      % setup.meshrefinementsplitmult and setup.meshrefinementcurveratio are
      % specific to hp-DarbyRao
      if strcmpi(setup.mesh.method, 'hp-DarbyRao');
        % check mesh.splitmult
        if isfield(usersetup.mesh, 'splitmult');
          if ~isempty(usersetup.mesh.splitmult);
            if isnumeric(usersetup.mesh.splitmult);
              if size(usersetup.mesh.splitmult,1) ~= 1 || size(usersetup.mesh.splitmult,2) ~= 1;
                % error if usersetup.mesh.splitmult is not a scalar
                error('GPOPS-II ERROR: setup.mesh.splitmult must be a scalar');
              end
              if usersetup.mesh.splitmult <= 0;
                % error if usersetup.mesh.splitmult is must be greater
                % or equal to 1
                error('GPOPS-II ERROR: setup.mesh.splitmult must be greater than zero');
              end
              setup.mesh.splitmult = usersetup.mesh.splitmult;
            else
              % error if usersetup.mesh.splitmult is not a numeric value
              error('GPOPS-II ERROR: setup.mesh.splitmult must be numeric');
            end
          else
            % set default
            setup.mesh.splitmult = defaults.mesh.splitmult;
          end
          % remove field 'splitmult'
          usersetup.mesh = rmfield(usersetup.mesh,'splitmult');
        else
          % set default
          setup.mesh.splitmult = defaults.mesh.splitmult;
        end
        
        % check mesh.curveratio
        if isfield(usersetup.mesh, 'curveratio');
          if ~isempty(usersetup.mesh.curveratio);
            if isnumeric(usersetup.mesh.curveratio);
              if size(usersetup.mesh.curveratio,1) ~= 1 || size(usersetup.mesh.curveratio,2) ~= 1;
                % error if usersetup.mesh.curveratio is not a scalar
                error('GPOPS-II ERROR: setup.mesh.curveratio must be a scalar');
              end
              if usersetup.mesh.curveratio <= 0;
                % error if usersetup.mesh.curveratio is must be greater
                % or equal to 1
                error('GPOPS-II ERROR: setup.mesh.curveratio must be greater than zero');
              end
              setup.mesh.curveratio = usersetup.mesh.curveratio;
            else
              % error if usersetup.mesh.curveratio is not a numeric value
              error('GPOPS-II ERROR: setup.mesh.curveratio must be numeric');
            end
          else
            % set default
            setup.mesh.curveratio = defaults.mesh.curveratio;
          end
          % remove field 'curveratio'
          usersetup.mesh = rmfield(usersetup.mesh,'curveratio');
        else
          % set default
          setup.mesh.curveratio = defaults.mesh.curveratio;
        end
      else
        % ignore setup.mesh.splitmult
        if isfield(usersetup.mesh, 'splitmult');
          % ignore setup.mesh.splitmult
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    Ignoring setup.mesh.splitmult because '...
            'setup.mesh.method = ''',setup.mesh.method,'''']);
          usersetup.mesh = rmfield(usersetup.mesh,'splitmult');
        end
        % ignore setup.mesh.curveratio
        if isfield(usersetup.mesh, 'curveratio');
          % ignore setup.mesh.curveratio
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    Ignoring setup.mesh.curveratio because '...
            'setup.mesh.method = ''',setup.mesh.method,'''']);
          usersetup.mesh = rmfield(usersetup.mesh,'curveratio');
        end
      end
      
      % setup.mesh.R is specific to hp-LiuRao
      if strcmpi(setup.mesh.method, 'hp-LiuRao');
        % check mesh.R
        if isfield(usersetup.mesh, 'R');
          if ~isempty(usersetup.mesh.R);
            if isnumeric(usersetup.mesh.R)
              if size(usersetup.mesh.R,1) ~= 1 || size(usersetup.mesh.R,2) ~= 1;
                % error if usersetup.mesh.R is not a scalar
                error('GPOPS-II ERROR: setup.mesh.R must be a scalar');
              end
              if usersetup.mesh.R <= 0;
                % error if usersetup.mesh.R is must be greater
                % or equal to 1
                error('GPOPS-II ERROR: setup.mesh.R must be greater than zero');
              end
              setup.mesh.R = usersetup.mesh.R;
            else
              % error if usersetup.mesh.R is not a numeric value
              error('GPOPS-II ERROR: setup.mesh.R must be numeric');
            end
          else
            % set default
            setup.mesh.R = defaults.mesh.R;
          end
          % remove field 'R'
          usersetup.mesh = rmfield(usersetup.mesh,'R');
        else
          % set default
          setup.mesh.R = defaults.mesh.R;
        end
      else
        % ignore setup.mesh.R
        if isfield(usersetup.mesh, 'R');
          % ignore setup.mesh.R
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    Ignoring setup.mesh.R because '...
            'setup.mesh.method = ''',setup.mesh.method,'''']);
          usersetup.mesh = rmfield(usersetup.mesh,'R');
        end
      end
      
      if strcmpi(setup.mesh.method, 'hp-LiuRao-Legendre')
        % check mesh.sigma
        if isfield(usersetup.mesh, 'sigma');
          if ~isempty(usersetup.mesh.sigma);
            if isnumeric(usersetup.mesh.sigma)
              if size(usersetup.mesh.sigma,1) ~= 1 || size(usersetup.mesh.sigma,2) ~= 1;
                % error if usersetup.mesh.sigma is not a scalar
                error('GPOPS-II ERROR: setup.mesh.sigma must be a scalar');
              end
              if usersetup.mesh.sigma <= 0;
                % error if usersetup.mesh.sigma is must be greater
                % or equal to 0
                error('GPOPS-II ERROR: setup.mesh.sigma must be greater than zero');
              end
              setup.mesh.sigma = usersetup.mesh.sigma;
            else
              % error if usersetup.mesh.sigma is not a numeric value
              error('GPOPS-II ERROR: setup.mesh.sigma must be numeric');
            end
          else
            % set default
            setup.mesh.sigma = defaults.mesh.sigma;
          end
          % remove field 'sigma'
          usersetup.mesh = rmfield(usersetup.mesh,'sigma');
        else
          % set default
          setup.mesh.sigma = defaults.mesh.sigma;
        end
      else
        % ignore setup.mesh.sigma
        if isfield(usersetup.mesh, 'sigma');
          % ignore setup.mesh.sigma
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    Ignoring setup.mesh.sigma because '...
            'setup.mesh.method = ''',setup.mesh.method,'''']);
          usersetup.mesh = rmfield(usersetup.mesh,'sigma');
        end
      end
    end
    
    % check for mesh.phase
    if isfield(usersetup.mesh, 'phase');
      % initial mesh must be provided for each phase
      if ~isempty(usersetup.mesh.phase);
        % check that phases in a single dimension
        meshphase = length(usersetup.mesh.phase);
        if meshphase ~= numel(usersetup.mesh.phase);
          % error phase not single dimension
          error('GPOPS-II ERROR: setup.mesh.phase must be a single dimension ');
        end
        % check that mesh has the correct number of phases
        if meshphase ~= numphase;
          error(['GPOPS-II ERROR: the initial mesh must be provided for each '...
            'phase, setup.mesh.phase needs to be the same size as setup.bounds.phase']);
        end
        
        if isfield(usersetup.mesh.phase, 'colpoints') && isfield(usersetup.mesh.phase, 'fraction');
          % colpoints and fraction must be same length in each phase
          % sum fraction must be == 1 in each phase
          % colpoints must be between 3 and 50 (proposed upper limit)
          for phasecount = 1:numphase;
            if isempty(usersetup.mesh.phase(phasecount).colpoints) && isempty(usersetup.mesh.phase(phasecount).fraction);
              % set defaults setup.derivatives.dependencies
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.phase(',num2str(phasecount),') '...
                ,num2str(defaults.initialmesh.numintervals),' equal length intervals with '...
                ,num2str(defaults.initialmesh.numcolpoints), ' collocation points in each interval']);
              
              % default 10 equal sections, 4 colpoints
              setup.mesh.phase(phasecount).colpoints = defaults.initialmesh.numcolpoints.*ones(1,defaults.initialmesh.numintervals);
              setup.mesh.phase(phasecount).fraction = 1/defaults.initialmesh.numintervals.*ones(1,defaults.initialmesh.numintervals);
            elseif isempty(usersetup.mesh.phase(phasecount).colpoints);
              % fraction not empty
              % fraction must be a row vector
              if size(usersetup.mesh.phase(phasecount).fraction,1) ~= 1;
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').fraction '...
                  'must be a row vector']);
              end
              % fraction must be greater than zero
              if any(usersetup.mesh.phase(phasecount).fraction <= 0);
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').fraction '...
                  'fraction for any interval must be greater than zero']);
              end
              % sum fraction must = 1 (1+- 10^-6 for a margin of safety)
              if sum(usersetup.mesh.phase(phasecount).fraction) < 0.99 || sum(usersetup.mesh.phase(phasecount).fraction) > 1.01;
                error(['GPOPS-II ERROR: sum(setup.mesh.phase(',phasecount,').fraction) '...
                  'must be equal to 1']);
              end
              Nint = size(usersetup.mesh.phase(phasecount).fraction,2);
              
              % set defaults setup.derivatives.dependencies
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.phase(',num2str(phasecount),').colpoints = '...
                ,num2str(defaults.initialmesh.numcolpoints), ' collocation points in each interval']);
              
              setup.mesh.phase(phasecount).colpoints = defaults.initialmesh.numcolpoints.*ones(1,Nint);
              setup.mesh.phase(phasecount).fraction = usersetup.mesh.phase(phasecount).fraction;
            elseif isempty(usersetup.mesh.phase(phasecount).fraction);
              % colpoints must be a row vector
              if size(usersetup.mesh.phase(phasecount).colpoints,1) ~= 1;
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').colpoints '...
                  'must be a row vector']);
              end
              % colpoints must be integers
              if any(ceil(usersetup.mesh.phase(phasecount).colpoints) ~= floor(usersetup.mesh.phase(phasecount).colpoints));
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').colpoints '...
                  'must have integer values']);
              end
              % colpoints must be 2 or greater
              if any(usersetup.mesh.phase(phasecount).colpoints < 2);
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').colpoints '...
                  'number of points in any interval can not be less than two']);
              end
              Nint = size(usersetup.mesh.phase(phasecount).colpoints,2);
              
              % set defaults setup.derivatives.dependencies
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.phase(',num2str(phasecount),').fraction = '...
                ,num2str(Nint),' equal length intervals']);
              
              setup.mesh.phase(phasecount).colpoints = usersetup.mesh.phase(phasecount).colpoints;
              setup.mesh.phase(phasecount).fraction = 1/Nint.*ones(1,Nint);
            else
              % colpoints must be a row vector
              if size(usersetup.mesh.phase(phasecount).colpoints,1) ~= 1;
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').colpoints '...
                  'must be a row vector']);
              end
              % colpoints must be integers
              if any(ceil(usersetup.mesh.phase(phasecount).colpoints) ~= floor(usersetup.mesh.phase(phasecount).colpoints));
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').colpoints '...
                  'must have integer values']);
              end
              % colpoints must be 2 or greater
              if any(usersetup.mesh.phase(phasecount).colpoints < 2);
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').colpoints '...
                  'number of points in any interval can not be less than two']);
              end
              % fraction must be a row vector
              if size(usersetup.mesh.phase(phasecount).fraction,1) ~= 1;
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').fraction '...
                  'must be a row vector']);
              end
              % fraction must be greater than zero
              if any(usersetup.mesh.phase(phasecount).fraction <= 0);
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').fraction '...
                  'fraction for any interval must be greater than zero']);
              end
              % sum fraction must = 1 (1+- 10^-6 for a margin of safety)
              if sum(usersetup.mesh.phase(phasecount).fraction) < 0.99 || sum(usersetup.mesh.phase(phasecount).fraction) > 1.01;
                error(['GPOPS-II ERROR: sum(setup.mesh.phase(',phasecount,').fraction) '...
                  'must be equal to 1']);
              end
              % colpoints and fraction must be same length in each phase
              if size(usersetup.mesh.phase(phasecount).colpoints,2) ~= size(usersetup.mesh.phase(phasecount).fraction,2);
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').colpoints '...
                  'and setup.mesh.phase(',phasecount,').fraction must have same length']);
              end
              
              setup.mesh.phase(phasecount).colpoints = usersetup.mesh.phase(phasecount).colpoints;
              setup.mesh.phase(phasecount).fraction = usersetup.mesh.phase(phasecount).fraction;
            end
          end
          % remove fields 'colpoints' and 'fraction'
          usersetup.mesh.phase = rmfield(usersetup.mesh.phase,'colpoints');
          usersetup.mesh.phase = rmfield(usersetup.mesh.phase,'fraction');
        elseif isfield(usersetup.mesh.phase, 'colpoints');
          for phasecount = 1:numphase;
            if ~isempty(usersetup.mesh.phase(phasecount).colpoints);
              % colpoints must be a row vector
              if size(usersetup.mesh.phase(phasecount).colpoints,1) ~= 1;
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').colpoints '...
                  'must be a row vector']);
              end
              % colpoints must be integers
              if any(ceil(usersetup.mesh.phase(phasecount).colpoints) ~= floor(usersetup.mesh.phase(phasecount).colpoints));
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').colpoints '...
                  'must have integer values']);
              end
              % colpoints must be 2 or greater
              if any(usersetup.mesh.phase(phasecount).colpoints < 2);
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').colpoints '...
                  'number of points in any interval can not be less than two']);
              end
              Nint = size(usersetup.mesh.phase(phasecount).colpoints,2);
              
              % set defaults setup.derivatives.dependencies
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.phase(',num2str(phasecount),').fraction = '...
                ,num2str(Nint),' equal length intervals']);
              
              setup.mesh.phase(phasecount).colpoints = usersetup.mesh.phase(phasecount).colpoints;
              setup.mesh.phase(phasecount).fraction = 1/Nint.*ones(1,Nint);
            else
              % set defaults setup.derivatives.dependencies
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.phase(',num2str(phasecount),') '...
                ,num2str(defaults.initialmesh.numintervals),' equal length intervals with '...
                ,num2str(defaults.initialmesh.numcolpoints), ' collocation points in each interval']);
              
              % default 10 equal sections, 4 colpoints
              setup.mesh.phase(phasecount).colpoints = defaults.initialmesh.numcolpoints.*ones(1,defaults.initialmesh.numintervals);
              setup.mesh.phase(phasecount).fraction = 1/defaults.initialmesh.numintervals.*ones(1,defaults.initialmesh.numintervals);
            end
          end
          % remove fields 'colpoints' and 'fraction'
          usersetup.mesh.phase = rmfield(usersetup.mesh.phase,'colpoints');
        elseif isfield(usersetup.mesh.phase, 'fraction');
          % colpoints and fraction must be same length in each phase
          % sum fraction must be == 1 in each phase
          % colpoints must be between 3 and 50 (proposed upper limit)
          for phasecount = 1:numphase;
            if ~isempty(usersetup.mesh.phase(phasecount).fraction);
              % fraction must be a row vector
              if size(usersetup.mesh.phase(phasecount).fraction,1) ~= 1;
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').fraction '...
                  'must be a row vector']);
              end
              % fraction must be greater than zero
              if any(usersetup.mesh.phase(phasecount).fraction <= 0);
                error(['GPOPS-II ERROR: setup.mesh.phase(',phasecount,').fraction '...
                  'fraction for any interval must be greater than zero']);
              end
              % sum fraction must = 1 (1+- 10^-6 for a margin of safety)
              if sum(usersetup.mesh.phase(phasecount).fraction) < 0.99 || sum(usersetup.mesh.phase(phasecount).fraction) > 1.01;
                error(['GPOPS-II ERROR: sum(setup.mesh.phase(',phasecount,').fraction) '...
                  'must be equal to 1']);
              end
              Nint = size(usersetup.mesh.phase(phasecount).fraction,2);
              
              % set defaults setup.derivatives.dependencies
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.phase(',num2str(phasecount),').colpoints = '...
                ,num2str(defaults.initialmesh.numcolpoints), ' collocation points in each interval']);
              
              setup.mesh.phase(phasecount).colpoints = defaults.initialmesh.numcolpoints.*ones(1,Nint);
              setup.mesh.phase(phasecount).fraction = usersetup.mesh.phase(phasecount).fraction;
            else
              % set defaults setup.derivatives.dependencies
              NumDefaults = NumDefaults + 1;
              DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.phase(',num2str(phasecount),') '...
                ,num2str(defaults.initialmesh.numintervals),' equal length intervals with '...
                ,num2str(defaults.initialmesh.numcolpoints), ' collocation points in each interval']);
              
              % default 10 equal sections, 4 colpoints
              setup.mesh.phase(phasecount).colpoints = defaults.initialmesh.numcolpoints.*ones(1,defaults.initialmesh.numintervals);
              setup.mesh.phase(phasecount).fraction = 1./defaults.initialmesh.numintervals.*ones(1,defaults.initialmesh.numintervals);
            end
          end
          % remove fields 'colpoints' and 'fraction'
          usersetup.mesh.phase = rmfield(usersetup.mesh.phase,'fraction');
        else
          % error phase is not provided
          error(['GPOPS-II ERROR: initial mesh colpoints and fraction for each phase is required to be provided '...
            'in setup.mesh.phase.colpoints and setup.mesh.phase.fraction']);
        end
        % check usersetup.guess for unknown fields
        % valid fields are 'phase', 'parameter'
        URF = fieldnames(usersetup.mesh.phase);
        for URFcount = 1:size(URF,1);
          NumWarnings = NumWarnings + 1;
          WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.mesh.phase.',URF{URFcount}]);
        end
      else
        % set defaults setup.derivatives.dependencies
        NumDefaults = NumDefaults + 1;
        DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.phase '...
          ,num2str(defaults.initialmesh.numintervals),' equal length intervals with '...
          ,num2str(defaults.initialmesh.numcolpoints), ' collocation points in each interval']);
        
        for phasecount = 1:numphase;
          % default 10 equal sections, 4 colpoints
          setup.mesh.phase(phasecount).colpoints = defaults.initialmesh.numcolpoints.*ones(1,defaults.initialmesh.numintervals);
          setup.mesh.phase(phasecount).fraction = 1./defaults.initialmesh.numintervals.*ones(1,defaults.initialmesh.numintervals);
        end
      end
      
      % remove field 'usersetup.mesh.phase'
      usersetup.mesh = rmfield(usersetup.mesh,'phase');
    else
      % set defaults setup.derivatives.dependencies
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.phase '...
        ,num2str(defaults.initialmesh.numintervals),' equal length intervals with '...
        ,num2str(defaults.initialmesh.numcolpoints), ' collocation points in each interval']);
      
      for phasecount = 1:numphase;
        % default 10 equal sections, 4 colpoints
        setup.mesh.phase(phasecount).colpoints = defaults.initialmesh.numcolpoints.*ones(1,defaults.initialmesh.numintervals);
        setup.mesh.phase(phasecount).fraction = 1./defaults.initialmesh.numintervals.*ones(1,defaults.initialmesh.numintervals);
      end
    end
    % check usersetup.mesh for unknown fields
    % valid fields are 'method', 'tolerance', 'maxiterations', 'colpointsmin',
    % 'colpointsmax', 'splitmult', 'curveratio', 'R'
    URF = fieldnames(usersetup.mesh);
    for URFcount = 1:size(URF,1);
      NumWarnings = NumWarnings + 1;
      WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.mesh.',URF{URFcount}]);
    end
  else
    % set defaults
    % set default setup.mesh.method
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.method = ',defaults.mesh.method]);
    setup.mesh.method = defaults.mesh.method;
    
    if ~strcmpi(setup.mesh.method, 'none');
      % set default setup.mesh.tolerance
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.tolerance = ',num2str(defaults.mesh.tolerance)]);
      setup.mesh.tolerance = defaults.mesh.tolerance;
      
      % set default setup.mesh.maxiterations
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.maxiterations = ',num2str(defaults.mesh.maxiterations)]);
      setup.mesh.maxiterations = defaults.mesh.maxiterations;
      
      % set default setup.mesh.colpointsmin
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.colpointsmin = ',num2str(defaults.mesh.colpointsmin)]);
      setup.mesh.colpointsmin = defaults.mesh.colpointsmin;
      
      % set default setup.mesh.colpointsmax
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.colpointsmax = ',num2str(defaults.mesh.colpointsmax)]);
      setup.mesh.colpointsmax = defaults.mesh.colpointsmax;
      
      if strcmpi(setup.mesh.method, 'hp-DarbyRao');
        % setup.mesh.splitmult and setup.mesh.curveratio are
        % specific to hp-DarbyRao
        setup.mesh.splitmult = defaults.mesh.splitmult;
        setup.mesh.curveratio = defaults.mesh.curveratio;
      elseif strcmpi(setup.mesh.method, 'hp-LiuRao');
        % setup.mesh.R is specific to hp-LiuRao
        setup.mesh.R = defaults.mesh.R;
      end
      
      % set defaults setup.derivatives.dependencies
      NumDefaults = NumDefaults + 1;
      DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.phase '...
        ,num2str(defaults.initialmesh.numintervals),' equal length intervals with '...
        ,num2str(defaults.initialmesh.numcolpoints), ' collocation points in each interval']);
      
      for phasecount = 1:numphase;
        % default 10 equal sections, 4 colpoints
        setup.mesh.phase(phasecount).colpoints = defaults.initialmesh.numcolpoints.*ones(1,defaults.initialmesh.numintervals);
        setup.mesh.phase(phasecount).fraction   = 1./defaults.initialmesh.numintervals.*ones(1,defaults.initialmesh.numintervals);
      end
    end
  end
  
  % remove field 'usersetup.mesh'
  usersetup = rmfield(usersetup,'mesh');
else
  % set defaults
  % set default setup.mesh.method
  NumDefaults = NumDefaults + 1;
  DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.method = ',defaults.mesh.method]);
  setup.mesh.method = defaults.mesh.method;
  
  if ~strcmpi(setup.mesh.method, 'none');
    % set default setup.mesh.tolerance
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.tolerance = ',num2str(defaults.mesh.tolerance)]);
    setup.mesh.tolerance = defaults.mesh.tolerance;
    
    % set default setup.mesh.maxiterations
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.maxiterations = ',num2str(defaults.mesh.maxiterations)]);
    setup.mesh.maxiterations = defaults.mesh.maxiterations;
    
    % set default setup.mesh.colpointsmin
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.colpointsmin = ',num2str(defaults.mesh.colpointsmin)]);
    setup.mesh.colpointsmin = defaults.mesh.colpointsmin;
    
    % set default setup.mesh.colpointsmax
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.colpointsmax = ',num2str(defaults.mesh.colpointsmax)]);
    setup.mesh.colpointsmax = defaults.mesh.colpointsmax;
    
    if strcmpi(setup.mesh.method, 'hp-DarbyRao');
      % setup.mesh.splitmult and setup.mesh.curveratio are
      % specific to hp-DarbyRao
      setup.mesh.splitmult = defaults.mesh.splitmult;
      setup.mesh.curveratio = defaults.mesh.curveratio;
    elseif strcmpi(setup.mesh.method, 'hp-LiuRao');
      % setup.mesh.R is specific to hp-LiuRao
      setup.mesh.R = defaults.mesh.R;
    end
    
    % set defaults setup.derivatives.dependencies
    NumDefaults = NumDefaults + 1;
    DefaultStr{NumDefaults} = (['    Using default setting setup.mesh.phase '...
      ,num2str(defaults.initialmesh.numintervals),' equal length intervals with '...
      ,num2str(defaults.initialmesh.numcolpoints), ' collocation points in each interval']);
    
    for phasecount = 1:numphase;
      % default 10 equal sections, 4 colpoints
      setup.mesh.phase(phasecount).colpoints = defaults.initialmesh.numcolpoints.*ones(1,defaults.initialmesh.numintervals);
      setup.mesh.phase(phasecount).fraction   = 1./defaults.initialmesh.numintervals.*ones(1,defaults.initialmesh.numintervals);
    end
  end
end

% check usersetup for field 'functions'
if isfield(usersetup,'functions');
  % check if usersetup.functions for field continuous
  if isfield(usersetup.functions,'continuous');
    % check class of usersetup.functions.continuous
    if isa(usersetup.functions.continuous, 'function_handle');
      setup.functions.continuous = usersetup.functions.continuous;
    elseif ischar(usersetup.functions.continuous);
      % if usersetup.functions.continuous is a character string convert to
      % function handle
      NumConflicts = NumConflicts + 1;
      ConflictsStr{NumConflicts} = (['    converting character string setup.functions.continuous '...
        'to a function handle']);
      setup.functions.continuous = str2func(usersetup.functions.continuous);
    else
      % error because usersetup.functions.continuous is not a string or
      % function handle
      error(['GPOPS-II ERROR: setup.functions.continuous must be a '...
        'function handle']);
    end
    % remove field 'usersetup.functions.continuous'
    usersetup.functions = rmfield(usersetup.functions,'continuous');
  else
    % error because usersetup.functions does not have field continuous
    error(['GPOPS-II ERROR: the continuous function must be provided '...
      'in the field setup.functions.continuous']);
  end
  
  % check if usersetup.functions for field endpoint
  if isfield(usersetup.functions,'endpoint');
    % check class of usersetup.functions.endpoint
    if isa(usersetup.functions.endpoint, 'function_handle');
      setup.functions.endpoint = usersetup.functions.endpoint;
    elseif ischar(usersetup.functions.endpoint);
      % if usersetup.functions.endpoint is a character string convert to
      % function handle
      NumConflicts = NumConflicts + 1;
      ConflictsStr{NumConflicts} = (['    converting character string setup.functions.endpoint '...
        'to a function handle']);
      setup.functions.endpoint = str2func(usersetup.functions.endpoint);
    else
      % error because usersetup.functions.endpoint is not a string or
      % function handle
      error(['GPOPS-II ERROR: setup.functions.endpoint must be a '...
        'function handle']);
    end
    % remove field 'usersetup.functions.endpoint'
    usersetup.functions = rmfield(usersetup.functions,'endpoint');
  else
    % error because usersetup.functions does not have field endpoint
    error(['GPOPS-II ERROR: the endpoint function must be provided '...
      'in the field setup.functions.endpoint']);
  end
  % check usersetup.functions for unknown fields
  % valid fields are 'continuous', 'endpoint'
  URF = fieldnames(usersetup.functions);
  for URFcount = 1:size(URF,1);
    NumWarnings = NumWarnings + 1;
    WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.functions.',URF{URFcount}]);
  end
  
  % remove field 'functions'
  usersetup = rmfield(usersetup,'functions');
else
  % error because no functions are provided
  error(['GPOPS-II ERROR: function '...
    'handles for the continuous and endpoint functions be provided '...
    'in the fields setup.functions.continuous and setup.functions.endpoint']);
end

% get input for user function from guess at 13 sample points
Nsamples = 13;
[continput, endpinput] = gpopsInputInterpGuessInternal(setup, Nsamples);

% try to evaluate the continuous function
try
  contoutput = feval(setup.functions.continuous, continput);
catch
  % error can not evaluate users continuous function
  error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
    ' can not be evaluated on the initial guess without error']);
end
% check number of phases in output
if size(contoutput,2) ~= numphase;
  % error continuous function has wrong number of phases
  error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
    ' needs to have output for each phase']);
end
% check if dynamics is field
if ~isfield(contoutput,'dynamics');
  % error missing dynamics
  error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
    ' output is missing required field output.dynamics']);
end
% check if path is field
if sum(numpath) > 0;
  if ~isfield(contoutput,'path');
    % error missing path
    error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
      ' output is missing required field output.path because path bounds are given']);
  end
else
  if isfield(contoutput,'path');
    % errorno path bounds
    error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
      ' output contains the field output.path when no path bounds are given']);
  end
end
% check if integrand is field
if sum(numintegral) > 0;
  if ~isfield(contoutput,'integrand');
    % error missing integrand
    error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
      ' output is missing required field output.integrand because integral bounds are given']);
  end
else
  if isfield(contoutput,'integrand');
    % error no integral bounds
    error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
      ' output contains the field output.integrand when no integral bounds are given']);
  end
end

% check each phase of continuous function output
for phasecount = 1:numphase;
  % check dynamics
  if isnumeric(contoutput(phasecount).dynamics)
    if size(contoutput(phasecount).dynamics,1) ~= Nsamples;
      % error dynamics wrong number of rows
      error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
        ' output(',num2str(phasecount),').dynamics must have as many rows as input.phase(',num2str(phasecount),').time']);
    end
    if size(contoutput(phasecount).dynamics,2) ~= numstate(phasecount);
      % error dynamics wrong number of columns
      error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
        ' output(',num2str(phasecount),').dynamics must have as many columns as setup.bounds.phase(',num2str(phasecount),').state']);
    end
    if any(any(isnan(contoutput(phasecount).dynamics)));
      % error dynamics has NaN
      error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
        ' output(',num2str(phasecount),').dynamics has values of NaN when evaluated at the initial guess']);
    end
  else
    % error dynamics is not numeric
    error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
      ' output(',num2str(phasecount),').dynamics must be numeric']);
  end
  % check path
  if numpath(phasecount) > 0;
    if isnumeric(contoutput(phasecount).path)
      if size(contoutput(phasecount).path,1) ~= Nsamples;
        % error path wrong number of rows
        error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
          ' output(',num2str(phasecount),').path must have as many rows as input.phase(',num2str(phasecount),').time']);
      end
      if size(contoutput(phasecount).path,2) ~= numpath(phasecount);
        % error path wrong number of columns
        error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
          ' output(',num2str(phasecount),').path must have as many columns as setup.bounds.phase(',num2str(phasecount),').path']);
      end
      if any(any(isnan(contoutput(phasecount).path)));
        % error path has NaN
        error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
          ' output(',num2str(phasecount),').path has values of NaN when evaluated at the initial guess']);
      end
    else
      % error path is not numeric
      error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
        ' output(',num2str(phasecount),').path must be numeric']);
    end
  end
  % check integral
  if numintegral(phasecount) > 0;
    if isnumeric(contoutput(phasecount).integrand)
      if size(contoutput(phasecount).integrand,1) ~= Nsamples;
        % error integrand wrong number of rows
        error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
          ' output(',num2str(phasecount),').integrand must have as many rows as input.phase(',num2str(phasecount),').time']);
      end
      if size(contoutput(phasecount).integrand,2) ~= numintegral(phasecount);
        % error integrand wrong number of columns
        error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
          ' output(',num2str(phasecount),').integrand must have as many columns as setup.bounds.phase(',num2str(phasecount),').integral']);
      end
      if any(any(isnan(contoutput(phasecount).integrand)));
        % error integrand has NaN
        error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
          ' output(',num2str(phasecount),').integrand has values of NaN when evaluated at the initial guess']);
      end
    else
      % error integrand is not numeric
      error(['GPOPS-II ERROR: the continuous function ', func2str(setup.functions.continuous),...
        ' output(',num2str(phasecount),').integrand must be numeric']);
    end
  end
end

% evaluate endpoint function
try
  endpoutput = feval(setup.functions.endpoint, endpinput);
catch
  % error can not evaluate users endpoint function
  error(['GPOPS-II ERROR: the endpoint function ', func2str(setup.functions.endpoint),...
    ' can not be evaluated on the initial guess without error']);
end
% check objective
if isfield(endpoutput,'objective');
  if isnumeric(endpoutput.objective);
    if size(endpoutput.objective,1) ~= 1 || size(endpoutput.objective,2) ~= 1;
      % error objective is not a scalar
      error(['GPOPS-II ERROR: the endpoint function ', func2str(setup.functions.endpoint),...
        ' output.objective must be a scalar']);
    end
    if isnan(endpoutput.objective);
      % error objective is NaN
      error(['GPOPS-II ERROR: the endpoint function ', func2str(setup.functions.endpoint),...
        ' output.objective is NaN when evaluated at the initial guess']);
    end
  else
    % error objective is not numeric
    error(['GPOPS-II ERROR: the endpoint function ', func2str(setup.functions.endpoint),...
      ' output.objective must be numeric']);
  end
else
  % error no objective
  error(['GPOPS-II ERROR: the endpoint function ', func2str(setup.functions.endpoint),...
    ' output is missing required field output.objective']);
end
% check events
if numeventgroup > 0;
  % check if eventgroup is field
  if ~isfield(endpoutput,'eventgroup');
    % error can not evaluate users continuous function
    error(['GPOPS-II ERROR: the endpoint function ', func2str(setup.functions.endpoint),...
      ' output is missing required field output.eventgroup because event bounds are given']);
  end
  % check if event is field
  if ~isfield(endpoutput.eventgroup,'event');
    % error can not evaluate users continuous function
    error(['GPOPS-II ERROR: the endpoint function ', func2str(setup.functions.endpoint),...
      ' output is missing required field output.eventgroup.event because event bounds are given']);
  end
  % check if correct number of eventgroups
  if size(endpoutput.eventgroup,2) ~= numeventgroup;
    % error can not evaluate users continuous function
    error(['GPOPS-II ERROR: the endpoint function ', func2str(setup.functions.endpoint),...
      ' output.eventgroup needs to have output for each eventgroup']);
  end
  %check all eventgroups
  for eventgroupcount = 1:numeventgroup;
    % check event
    if ~isnumeric(endpoutput.eventgroup(eventgroupcount).event);
      % error event not numeric
      error(['GPOPS-II ERROR: the endpoint function ', func2str(setup.functions.endpoint),...
        ' output.eventgroup(',num2str(eventgroupcount),').event must be numeric']);
    end
    % check event size
    if size(endpoutput.eventgroup(eventgroupcount).event,2) ~= numevent(eventgroupcount) || size(endpoutput.eventgroup(eventgroupcount).event,1) ~= 1;
      % error event wrong size
      error(['GPOPS-II ERROR: the endpoint function ', func2str(setup.functions.endpoint),...
        ' output.eventgroup(',num2str(eventgroupcount),').event must be same size as setup.bounds.eventgroup(',num2str(eventgroupcount),')']);
    end
  end
else
  if isfield(endpoutput,'eventgroup');
    % error can not evaluate users continuous function
    error(['GPOPS-II ERROR: the endpoint function ', func2str(setup.functions.endpoint),...
      ' output contains the field output.eventgroup when no event bounds are given']);
  end
end

% check if analytic derivatives are supplied
if strcmpi(setup.derivatives.supplier, 'analytic');
  % check usersetup for field 'functionsgrd'
  if isfield(usersetup,'functionsgrd');
    % check if usersetup.functionsgrd for field continuous
    if isfield(usersetup.functionsgrd,'continuous');
      % check class of usersetup.functionsgrd.continuous
      if isa(usersetup.functionsgrd.continuous, 'function_handle');
        setup.functionsgrd.continuous = usersetup.functionsgrd.continuous;
      elseif ischar(usersetup.functionsgrd.continuous);
        % if usersetup.functionsgrd.continuous is a character string converted to
        % function handle
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    converting character string setup.functionsgrd.continuous '...
          'to a function handle']);
        setup.functionsgrd.continuous = str2func(usersetup.functionsgrd.continuous);
      else
        % error because usersetup.functionsgrd.continuous is not a string or
        % function handle
        error(['GPOPS-II ERROR: setup.functionsgrd.continuous must be a '...
          'function handle']);
      end
      % remove field 'usersetup.functionsgrd.continuous'
      usersetup.functionsgrd = rmfield(usersetup.functionsgrd,'continuous');
    else
      % error because usersetup.functionsgrd does not have field continuous
      error(['GPOPS-II ERROR: the continuous first derivative '...
        'function handle must be provided in the field '...
        'setup.functionsgrd.continuous when using analytic derivatives']);
    end
    % check if usersetup.functionsgrd for field endpoint
    if isfield(usersetup.functionsgrd,'endpoint');
      % check class of usersetup.functionsgrd.endpoint
      if isa(usersetup.functionsgrd.endpoint, 'function_handle');
        setup.functionsgrd.endpoint = usersetup.functionsgrd.endpoint;
      elseif ischar(usersetup.functionsgrd.endpoint);
        % if usersetup.functionsgrd.endpoint is a character string convert to
        % function handle
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    converting character string setup.functionsgrd.endpoint '...
          'to a function handle']);
        setup.functionsgrd.endpoint = str2func(usersetup.functionsgrd.endpoint);
      else
        % error because usersetup.functionsgrd.endpoint is not a string or
        % function handle
        error(['GPOPS-II ERROR: setup.functionsgrd.endpoint must be a '...
          'function handle']);
      end
      % remove field 'usersetup.functionsgrd.endpoint'
      usersetup.functionsgrd = rmfield(usersetup.functionsgrd,'endpoint');
    else
      % error because usersetup.functionsgrd does not have field endpoint
      error(['GPOPS-II ERROR: the endpoint first derivative '...
        'function handle must be provided in the field '...
        'setup.functionsgrd.endpoint when using analytic derivatives']);
    end
  else
    % error because no functionsgrd are provided
    error(['GPOPS-II ERROR: function '...
      'handles for the continuous and endpoint first derivative functions '...
      'must be provided in the fields setup.functionsgrd.continuous and '...
      'setup.functionsgrd.endpoint when using analytic derivatives']);
  end
  % check usersetup.functionsgrd for unknown fields
  % valid fields are 'continuous', 'endpoint'
  URF = fieldnames(usersetup.functionsgrd);
  for URFcount = 1:size(URF,1);
    NumWarnings = NumWarnings + 1;
    WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.functionsgrd.',URF{URFcount}]);
  end
  
  % remove field 'functionsgrd'
  usersetup = rmfield(usersetup,'functionsgrd');
  
  % check usersetup for field 'functionshes' if derivative level is second
  if strcmpi(setup.derivatives.derivativelevel, 'second');
    % check usersetup for field 'functionshes'
    if isfield(usersetup,'functionshes');
      % check if usersetup.functionshes for field continuous
      if isfield(usersetup.functionshes,'continuous');
        % check class of usersetup.functionshes.continuous
        if isa(usersetup.functionshes.continuous, 'function_handle');
          setup.functionshes.continuous = usersetup.functionshes.continuous;
        elseif ischar(usersetup.functionshes.continuous);
          % if usersetup.functionshes.continuous is a character string convert to
          % function handle
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    converting character string setup.functionshes.continuous '...
            'to a function handle']);
          setup.functionshes.continuous = str2func(usersetup.functionshes.continuous);
        else
          % error because usersetup.functionshes.continuous is not a string or
          % function handle
          error(['GPOPS-II ERROR: setup.functionshes.continuous must be a '...
            'function handle']);
        end
        % remove field 'usersetup.functionshes.continuous'
        usersetup.functionshes = rmfield(usersetup.functionshes,'continuous');
      else
        % error because usersetup.functionshes does not have field continuous
        error(['GPOPS-II ERROR: the continuous second derivative '...
          'function handle must be provided in the field '...
          'setup.functionshes.continuous when using analytic derivatives '...
          'with second derivatives']);
      end
      % check if usersetup.functionshes for field endpoint
      if isfield(usersetup.functionshes,'endpoint');
        % check class of usersetup.functionshes.endpoint
        if isa(usersetup.functionshes.endpoint, 'function_handle');
          setup.functionshes.endpoint = usersetup.functionshes.endpoint;
        elseif ischar(usersetup.functionshes.endpoint);
          % if usersetup.functionshes.endpoint is a character string convert to
          % function handle
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    converting character string setup.functionshes.endpoint '...
            'to a function handle']);
          setup.functionshes.endpoint = str2func(usersetup.functionshes.endpoint);
        else
          % error because usersetup.functionshes.endpoint is not a string or
          % function handle
          error(['GPOPS-II ERROR: setup.functionshes.endpoint must be a '...
            'function handle']);
        end
        % remove field 'usersetup.functionshes.endpoint'
        usersetup.functionshes = rmfield(usersetup.functionshes,'endpoint');
      else
        % error because usersetup.functionshes does not have field endpoint
        error(['GPOPS-II ERROR: the endpoint second derivative '...
          'function handle must be provided in the field '...
          'setup.functionshes.endpoint when using analytic derivatives '...
          'with second derivatives']);
      end
    else
      % error because no functionshes are provided
      error(['GPOPS-II ERROR: function '...
        'handles for the continuous and endpoint second derivative functions '...
        'must be provided in the fields setup.functionshes.continuous and '...
        'setup.functionshes.endpoint when using analytic derivatives '...
        'with second derivatives']);
    end
    % check usersetup.functionshes for unknown fields
    % valid fields are 'continuous', 'endpoint'
    URF = fieldnames(usersetup.functionshes);
    for URFcount = 1:size(URF,1);
      NumWarnings = NumWarnings + 1;
      WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.functionshes.',URF{URFcount}]);
    end
    
    % remove field 'functionshes'
    usersetup = rmfield(usersetup,'functionshes');
  else
    % check if usersetup.functionshes is a field
    % ignore functionshes
    if isfield(usersetup,'functionshes');
      NumConflicts = NumConflicts + 1;
      ConflictsStr{NumConflicts} = (['    Ignoring setup.functionshes because '...
        'derivatives.derivativelevel = ',setup.derivatives.derivativelevel]);
      usersetup = rmfield(usersetup,'functionshes');
    end
  end
  
  % Test analytic Hes functions ______________________________________________________________________________
  % __________________________________________________________________________________________________________
  
else
  % check if usersetup.functionsgrd is a field
  % ignore functionsgrd
  if isfield(usersetup,'functionsgrd');
    NumConflicts = NumConflicts + 1;
    ConflictsStr{NumConflicts} = (['    Ignoring setup.functionsgrd because '...
      'setup.derivatives.supplier = ''',setup.derivatives.supplier,'''']);
    usersetup = rmfield(usersetup,'functionsgrd');
  end
  % check if usersetup.functionshes is a field
  % ignore functionshes
  if isfield(usersetup,'functionshes');
    NumConflicts = NumConflicts + 1;
    ConflictsStr{NumConflicts} = (['    Ignoring setup.functionshes because '...
      'setup.derivatives.supplier = ''',setup.derivatives.supplier,'''']);
    usersetup = rmfield(usersetup,'functionshes');
  end
end

% check if adigator derivatives are supplied
if strcmpi(setup.derivatives.supplier, 'adigator');
  % check if adigator exist
  if exist('adigator.m','file') < 2;
    % adigator not installed
    disp('AdiGator can not be used because it can not be found in the MATLAB path')
    disp('to obtain AdiGator please visit the AdiGator SourceForge website (link given below)')
    disp('<a href="http://sourceforge.net/projects/adigator/">http://sourceforge.net/projects/adigator/</a>.')
    error('GPOPS-II ERROR: AdiGator not found in MATLAB path');
  end
  
  % check usersetup for field 'adigatorgrd'
  if isfield(usersetup,'adigatorgrd');
    % check if usersetup.adigatorgrd for field continuous
    if isfield(usersetup.adigatorgrd,'continuous');
      % check class of usersetup.adigatorgrd.continuous
      if isa(usersetup.adigatorgrd.continuous, 'function_handle');
        setup.adigatorgrd.continuous = usersetup.adigatorgrd.continuous;
      elseif ischar(usersetup.adigatorgrd.continuous);
        % if usersetup.adigatorgrd.continuous is a character string convert to
        % function handle
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    converting character string setup.adigatorgrd.continuous '...
          'to a function handle']);
        setup.adigatorgrd.continuous = str2func(usersetup.adigatorgrd.continuous);
      else
        % error because usersetup.adigatorgrd.continuous is not a string or
        % function handle
        error(['GPOPS-II ERROR: setup.adigatorgrd.continuous must be a '...
          'function handle']);
      end
      % remove field 'usersetup.adigatorgrd.continuous'
      usersetup.adigatorgrd = rmfield(usersetup.adigatorgrd,'continuous');
    else
      % error because usersetup.adigatorgrd does not have field continuous
      error(['GPOPS-II ERROR: the continuous first derivative '...
        'function handle must be provided in the field '...
        'setup.adigatorgrd.continuous when supplying adigator derivatives']);
    end
    % check if usersetup.adigatorgrd for field endpoint
    if isfield(usersetup.adigatorgrd,'endpoint');
      % check class of usersetup.adigatorgrd.endpoint
      if isa(usersetup.adigatorgrd.endpoint, 'function_handle');
        setup.adigatorgrd.endpoint = usersetup.adigatorgrd.endpoint;
      elseif ischar(usersetup.adigatorgrd.endpoint);
        % if usersetup.adigatorgrd.endpoint is a character string convert to
        % function handle
        NumConflicts = NumConflicts + 1;
        ConflictsStr{NumConflicts} = (['    converting character string setup.adigatorgrd.endpoint '...
          'to a function handle']);
        setup.adigatorgrd.endpoint = str2func(usersetup.adigatorgrd.endpoint);
      else
        % error because usersetup.adigatorgrd.endpoint is not a string or
        % function handle
        error(['GPOPS-II ERROR: setup.adigatorgrd.endpoint must be a '...
          'function handle']);
      end
      % remove field 'usersetup.adigatorgrd.endpoint'
      usersetup.adigatorgrd = rmfield(usersetup.adigatorgrd,'endpoint');
    else
      % error because usersetup.adigatorgrd does not have field endpoint
      error(['GPOPS-II ERROR: the endpoint first derivative '...
        'function handle must be provided in the field '...
        'setup.adigatorgrd.endpoint when supplying adigator derivatives']);
    end
    % check usersetup.adigatorgrd for unknown fields
    % valid fields are 'continuous', 'endpoint'
    URF = fieldnames(usersetup.adigatorgrd);
    for URFcount = 1:size(URF,1);
      NumWarnings = NumWarnings + 1;
      WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.adigatorgrd.',URF{URFcount}]);
    end
    
    % remove field 'adigatorgrd'
    usersetup = rmfield(usersetup,'adigatorgrd');
    
    % make first derivatives flag false
    makeadigatorfirst = false;
  else
    % make first derivatives flag true
    makeadigatorfirst = true;
  end
  
  % check usersetup for field 'adigatorhes' if derivative level is second
  if strcmpi(setup.derivatives.derivativelevel, 'second');
    % check usersetup for field 'adigatorhes'
    if isfield(usersetup,'adigatorhes');
      if makeadigatorfirst
        % error because no adigatorgrd are provided when second derivatives
        % are provided
        error(['GPOPS-II ERROR: the function '...
          'handles for the continuous and endpoint first derivative functions must '...
          'be provided in the fields setup.adigatorgrd.continuous and '...
          'setup.adigatorgrd.endpoint when supplying adigator derivatives '...
          'with setup.derivativelevel = ''second''']);
      end
      
      % check if usersetup.adigatorhes for field continuous
      if isfield(usersetup.adigatorhes,'continuous');
        % check class of usersetup.adigatorhes.continuous
        if isa(usersetup.adigatorhes.continuous, 'function_handle');
          setup.adigatorhes.continuous = usersetup.adigatorhes.continuous;
        elseif ischar(usersetup.adigatorhes.continuous);
          % if usersetup.adigatorhes.continuous is a character string convert to
          % function handle
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    converting character string setup.adigatorhes.continuous '...
            'to a function handle']);
          setup.adigatorhes.continuous = str2func(usersetup.adigatorhes.continuous);
        else
          % error because usersetup.adigatorhes.continuous is not a string or
          % function handle
          error(['GPOPS-II ERROR: setup.adigatorhes.continuous must be a '...
            'function handle']);
        end
        % remove field 'usersetup.adigatorhes.continuous'
        usersetup.adigatorhes = rmfield(usersetup.adigatorhes,'continuous');
      else
        % error because usersetup.adigatorhes does not have field continuous
        error(['GPOPS-II ERROR: the continuous second derivative '...
          'function handle must be provided in the field '...
          'setup.adigatorhes.continuous when supplying adigator derivatives '...
          'with second derivatives']);
      end
      % check if usersetup.adigatorhes for field endpoint
      if isfield(usersetup.adigatorhes,'endpoint');
        % check class of usersetup.adigatorhes.endpoint
        if isa(usersetup.adigatorhes.endpoint, 'function_handle');
          setup.adigatorhes.endpoint = usersetup.adigatorhes.endpoint;
        elseif ischar(usersetup.adigatorhes.endpoint);
          % if usersetup.adigatorhes.endpoint is a character string convert to
          % function handle
          NumConflicts = NumConflicts + 1;
          ConflictsStr{NumConflicts} = (['    converting character string setup.adigatorhes.endpoint '...
            'to a function handle']);
          setup.adigatorhes.endpoint = str2func(usersetup.adigatorhes.endpoint);
        else
          % error because usersetup.adigatorhes.endpoint is not a string or
          % function handle
          error(['GPOPS-II ERROR: setup.adigatorhes.endpoint must be a '...
            'function handle']);
        end
        % remove field 'usersetup.adigatorhes.endpoint'
        usersetup.adigatorhes = rmfield(usersetup.adigatorhes,'endpoint');
      else
        % error because usersetup.adigatorhes does not have field endpoint
        error(['GPOPS-II ERROR: the endpoint second derivative '...
          'function handle must be provided in the field '...
          'setup.adigatorhes.endpoint when supplying adigator derivatives '...
          'with second derivatives']);
      end
      % check usersetup.adigatorhes for unknown fields
      % valid fields are 'continuous', 'endpoint'
      URF = fieldnames(usersetup.adigatorhes);
      for URFcount = 1:size(URF,1);
        NumWarnings = NumWarnings + 1;
        WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.adigatorhes.',URF{URFcount}]);
      end
      
      % remove field 'adigatorhes'
      usersetup = rmfield(usersetup,'adigatorhes');
      
      % make second derivatives flag false
      makeadigatorsecond = false;
    else
      % make second derivatives flag true
      makeadigatorsecond = true;
    end
  else
    % make second derivatives flag false
    makeadigatorsecond = false;
    % check if usersetup.adigatorhes is a field
    % ignore adigatorhes
    if isfield(usersetup,'adigatorhes');
      NumConflicts = NumConflicts + 1;
      ConflictsStr{NumConflicts} = (['    Ignoring setup.adigatorhes because '...
        'derivatives.derivativelevel = ',setup.derivatives.derivativelevel]);
      usersetup = rmfield(usersetup,'adigatorhes');
    end
  end
  
  % Make adigator functions (if needed)
  if strcmpi(setup.derivatives.derivativelevel, 'first');
    % make adigator first derivatives only
    if makeadigatorfirst;
      %       get adigator default filenames
      %       adigatorGrdContName = [func2str(setup.functions.continuous),'ADiGatorGrd'];
      %       adigatorGrdEndpName = [func2str(setup.functions.endpoint),'ADiGatorGrd'];
      
      %       check if adigator files and .mat files exsist
      %       if (exist([adigatorGrdContName,'.m'],'file') >= 2) && ...
      %           (exist([adigatorGrdContName,'.mat'],'file') >= 2) && ...
      %           (exist([adigatorGrdEndpName,'.m'],'file') >= 2) && ...
      %           (exist([adigatorGrdEndpName,'.mat'],'file') >= 2);
      %         % get directory information
      %         ContfunInfo = dir([func2str(setup.functions.continuous),'.m']);
      %         EndpfunInfo = dir([func2str(setup.functions.endpoint),'.m']);
      %         % get adigaotr grd info
      %         ContAdigatorGrdInfo = dir([adigatorGrdContName,'.m']);
      %         EndpAdigatorGrdInfo = dir([adigatorGrdEndpName,'.m']);
      %         % check if modification dates are newer than the user functions
      %         if ContAdigatorGrdInfo.datenum > ContfunInfo.datenum && ...
      %             EndpAdigatorGrdInfo.datenum > EndpfunInfo.datenum;
      %           setup.adigatorgrd.continuous = str2func(adigatorGrdContName);
      %           setup.adigatorgrd.endpoint = str2func(adigatorGrdEndpName);
      %           % resolve conflict
      %           NumConflicts = NumConflicts + 1;
      %           ConflictsStr{NumConflicts} = (['    using existing Adigator functions '...
      %             'setup.adigatorgrd.continuous = @',adigatorGrdContName,]);
      %           NumConflicts = NumConflicts + 1;
      %           ConflictsStr{NumConflicts} = (['    using existing Adigator functions '...
      %             'setup.adigatorgrd.endpoint = @',adigatorGrdEndpName,]);
      %         else
      %           % makes new adigator files
      %           try
      %             adigatorfilenames = gpopsAdigatorGenFiles(setup);
      %           catch
      %             % adigator could not make derivative files
      %             error('GPOPS-II ERROR: AdiGator could not produce derivative files');
      %           end
      %           setup.adigatorgrd.continuous = str2func(adigatorfilenames.ContGrd);
      %           setup.adigatorgrd.endpoint = str2func(adigatorfilenames.EndpGrd);
      %         end
      %       else
      %         % makes new adigator files
      %         try
      %           adigatorfilenames = gpopsAdigatorGenFiles(setup);
      %         catch
      %           % adigator could not make derivative files
      %           error('GPOPS-II ERROR: AdiGator could not produce derivative files');
      %         end
      %         setup.adigatorgrd.continuous = str2func(adigatorfilenames.ContGrd);
      %         setup.adigatorgrd.endpoint = str2func(adigatorfilenames.EndpGrd);
      %       end
      
      % makes new adigator files
      try
        adigatorfilenames = gpopsAdigatorGenFiles(setup);
      catch
        % adigator could not make derivative files
        error('GPOPS-II ERROR: AdiGator could not produce derivative files');
      end
      setup.adigatorgrd.continuous = str2func(adigatorfilenames.ContGrd);
      setup.adigatorgrd.endpoint = str2func(adigatorfilenames.EndpGrd);
    end
  elseif strcmpi(setup.derivatives.derivativelevel, 'second');
    % make adigator second derivatives
    if makeadigatorfirst && makeadigatorsecond;
      %       check if adigator files exsist
      %       adigatorGrdContName = [func2str(setup.functions.continuous),'ADiGatorGrd'];
      %       adigatorGrdEndpName = [func2str(setup.functions.endpoint),'ADiGatorGrd'];
      %       adigatorHesContName = [func2str(setup.functions.continuous),'ADiGatorHes'];
      %       adigatorHesEndpName = [func2str(setup.functions.endpoint),'ADiGatorHes'];
      
      %       check if adigator files and .mat files exsist
      %       if (exist([adigatorGrdContName,'.m'],'file') >= 2) && ...
      %           (exist([adigatorGrdContName,'.mat'],'file') >= 2) && ...
      %           (exist([adigatorGrdEndpName,'.m'],'file') >= 2) && ...
      %           (exist([adigatorGrdEndpName,'.mat'],'file') >= 2) && ...
      %           (exist([adigatorHesContName,'.m'],'file') >= 2) && ...
      %           (exist([adigatorHesContName,'.mat'],'file') >= 2) && ...
      %           (exist([adigatorHesEndpName,'.m'],'file') >= 2) && ...
      %           (exist([adigatorHesEndpName,'.mat'],'file') >= 2);
      %
      %         % get directory information
      %         ContfunInfo = dir([func2str(setup.functions.continuous),'.m']);
      %         EndpfunInfo = dir([func2str(setup.functions.endpoint),'.m']);
      %         % get adigaotr grd info
      %         ContAdigatorGrdInfo = dir([adigatorGrdContName,'.m']);
      %         EndpAdigatorGrdInfo = dir([adigatorGrdEndpName,'.m']);
      %         % get adigator hes info
      %         ContAdigatorHesInfo = dir([adigatorHesContName,'.m']);
      %         EndpAdigatorHesInfo = dir([adigatorHesEndpName,'.m']);
      %         % check if modification dates are newer than the user functions
      %         if ContAdigatorGrdInfo.datenum > ContfunInfo.datenum && ...
      %             EndpAdigatorGrdInfo.datenum > EndpfunInfo.datenum && ...
      %             ContAdigatorHesInfo.datenum > ContfunInfo.datenum && ...
      %             EndpAdigatorHesInfo.datenum > EndpfunInfo.datenum;
      %
      %           setup.adigatorgrd.continuous = str2func(adigatorGrdContName);
      %           setup.adigatorgrd.endpoint = str2func(adigatorGrdEndpName);
      %           setup.adigatorhes.continuous = str2func(adigatorHesContName);
      %           setup.adigatorhes.endpoint = str2func(adigatorHesEndpName);
      %           % resolve conflict
      %           NumConflicts = NumConflicts + 1;
      %           ConflictsStr{NumConflicts} = (['    using existing Adigator functions '...
      %             'setup.adigatorgrd.continuous = @',adigatorGrdContName,]);
      %           NumConflicts = NumConflicts + 1;
      %           ConflictsStr{NumConflicts} = (['    using existing Adigator functions '...
      %             'setup.adigatorgrd.endpoint = @',adigatorGrdEndpName,]);
      %           NumConflicts = NumConflicts + 1;
      %           ConflictsStr{NumConflicts} = (['    using existing Adigator functions '...
      %             'setup.adigatorhes.continuous = @',adigatorHesContName,]);
      %           NumConflicts = NumConflicts + 1;
      %           ConflictsStr{NumConflicts} = (['    using existing Adigator functions '...
      %             'setup.adigatorhes.endpoint = @',adigatorHesEndpName,]);
      %         else
      %           % makes new adigator files
      %           try
      %             adigatorfilenames = gpopsAdigatorGenFiles(setup);
      %           catch
      %             % adigator could not make derivative files
      %             error('GPOPS-II ERROR: AdiGator could not produce derivative files');
      %           end
      %           setup.adigatorgrd.continuous = str2func(adigatorfilenames.ContGrd);
      %           setup.adigatorgrd.endpoint = str2func(adigatorfilenames.EndpGrd);
      %           setup.adigatorhes.continuous = str2func(adigatorfilenames.ContHes);
      %           setup.adigatorhes.endpoint = str2func(adigatorfilenames.EndpHes);
      %         end
      %       else
      %         % makes new adigaotr files
      %         try
      %           adigatorfilenames = gpopsAdigatorGenFiles(setup);
      %         catch
      %           % adigator could not make derivative files
      %           error('GPOPS-II ERROR: AdiGator could not produce derivative files');
      %         end
      %         setup.adigatorgrd.continuous = str2func(adigatorfilenames.ContGrd);
      %         setup.adigatorgrd.endpoint = str2func(adigatorfilenames.EndpGrd);
      %         setup.adigatorhes.continuous = str2func(adigatorfilenames.ContHes);
      %         setup.adigatorhes.endpoint = str2func(adigatorfilenames.EndpHes);
      %       end
      
      % makes new adigator files
      try
        adigatorfilenames = gpopsAdigatorGenFiles(setup);
      catch
        % adigator could not make derivative files
        error('GPOPS-II ERROR: AdiGator could not produce derivative files');
      end
      setup.adigatorgrd.continuous = str2func(adigatorfilenames.ContGrd);
      setup.adigatorgrd.endpoint = str2func(adigatorfilenames.EndpGrd);
      setup.adigatorhes.continuous = str2func(adigatorfilenames.ContHes);
      setup.adigatorhes.endpoint = str2func(adigatorfilenames.EndpHes);
    elseif ~makeadigatorfirst && makeadigatorsecond;
      % error because no adigatorgrd are provided when second derivatives
      % are provided
      error(['GPOPS-II ERROR: the function '...
        'handles for the AdiGator generated continuous and endpoint second derivative functions must '...
        'be provided in the fields setup.adigatorhes.continuous and '...
        'setup.adigatorhes.endpoint when supplying adigator derivatives '...
        'with setup.derivativelevel = ''second''']);
    elseif makeadigatorfirst && ~makeadigatorsecond;
      % error because no adigatorgrd are provided when second derivatives
      % are provided
      error(['GPOPS-II ERROR: the function '...
        'handles for the AdiGator generated continuous and endpoint first derivative functions must '...
        'be provided in the fields setup.adigatorgrd.continuous and '...
        'setup.adigatorgrd.endpoint when supplying adigator derivatives '...
        'with setup.derivativelevel = ''second''']);
    end
  end
  
  
  % Test adigator functions ------------------------------------------------------------------------------------------------------------------------------------------------------------
  % ------------------------------------------------------------------------------------------------------------------------------------------------------------
  
  
else
  % check if usersetup.adigatorgrd is a field
  % ignore adigatorgrd
  if isfield(usersetup,'adigatorgrd');
    NumConflicts = NumConflicts + 1;
    ConflictsStr{NumConflicts} = (['    Ignoring setup.adigatorgrd because '...
      'setup.derivatives.supplier = ''',setup.derivatives.supplier,'''']);
    usersetup = rmfield(usersetup,'adigatorgrd');
  end
  % check if usersetup.adigatorhes is a field
  % ignore adigatorhes
  if isfield(usersetup,'adigatorhes');
    NumConflicts = NumConflicts + 1;
    ConflictsStr{NumConflicts} = (['    Ignoring setup.adigatorhes because '...
      'setup.derivatives.supplier = ''',setup.derivatives.supplier,'''']);
    usersetup = rmfield(usersetup,'adigatorhes');
  end
end

% check usersetup for unknown fields
% valid fields
% 'name'
% 'method'
% 'displaylevel'
% 'functions'
% 'functionsgrd'
% 'functionshes'
% 'adigatorgrd'
% 'adigatorhes'
% 'mesh'
% 'auxdata'
% 'bounds'
% 'guess'
% 'derivatives'
% 'nlp'
% 'scales'
URF = fieldnames(usersetup);
for URFcount = 1:size(URF,1);
  NumWarnings = NumWarnings + 1;
  WarningsStr{NumWarnings} = (['    Ignoring unrecognized field setup.',URF{URFcount}]);
end

% set display level
probinfo.displaylevel = setup.displaylevel;

% save probinfo struct
% get OCP function names
probinfo.contfunction = setup.functions.continuous;
probinfo.endpfunction = setup.functions.endpoint;

% set derivative level
if strcmpi(setup.derivatives.derivativelevel,'first');
  probinfo.derivativelevel = 1;
elseif strcmpi(setup.derivatives.derivativelevel,'second');
  probinfo.derivativelevel = 2;
end

if strcmpi(setup.derivatives.supplier, 'analytic');
  probinfo.analyticflag = true;
  probinfo.adigatorflag = false;
  % get OCP analytic first derivative Grdfunction names
  probinfo.contgrd = setup.functionsgrd.continuous;
  probinfo.endpgrd = setup.functionsgrd.endpoint;
  % get OCP analytic second derivative Hesfunction names
  if probinfo.derivativelevel == 2;
    probinfo.conthes = setup.functionshes.continuous;
    probinfo.endphes = setup.functionshes.endpoint;
  end
elseif strcmpi(setup.derivatives.supplier, 'adigator');
  probinfo.adigatorflag = true;
  probinfo.analyticflag = false;
  % get OCP AD first derivative Grdfunction names
  probinfo.adigator.contgrd = setup.adigatorgrd.continuous;
  probinfo.adigator.endpgrd = setup.adigatorgrd.endpoint;
  % get OCP AD second derivative Hesfunction names
  if probinfo.derivativelevel == 2;
    probinfo.adigator.conthes = setup.adigatorhes.continuous;
    probinfo.adigator.endphes = setup.adigatorhes.endpoint;
  end
else
  % base step size
  probinfo.stepsize1 = setup.derivatives.stepsize1;
  if probinfo.derivativelevel == 2;
    probinfo.stepsize2 = setup.derivatives.stepsize2;
  end
  
  % define function handles for sparse finite difference methods
  probinfo.analyticflag = false;
  probinfo.adigatorflag = false;
  if strcmpi(setup.derivatives.supplier, 'sparseCD');
    probinfo.contgrd = @gpopsContFirstCD;
    probinfo.endpgrd = @gpopsEndpFirstCD;
    probinfo.objgrd = @gpopsObjFirstCD;
    probinfo.eventgrd = @gpopsEventFirstCD;
    if probinfo.derivativelevel == 2;
      probinfo.conthes = @gpopsContSecondCD;
      probinfo.endphes = @gpopsEndpSecondCD;
    end
  elseif strcmpi(setup.derivatives.supplier, 'sparseFD');
    probinfo.contgrd = @gpopsContFirstFD;
    probinfo.endpgrd = @gpopsEndpFirstFD;
    probinfo.objgrd = @gpopsObjFirstFD;
    probinfo.eventgrd = @gpopsEventFirstFD;
    if probinfo.derivativelevel == 2;
      probinfo.conthes = @gpopsContSecondFD;
      probinfo.endphes = @gpopsEndpSecondFD;
    end
  elseif strcmpi(setup.derivatives.supplier, 'sparseBD');
    probinfo.contgrd = @gpopsContFirstBD;
    probinfo.endpgrd = @gpopsEndpFirstBD;
    probinfo.objgrd = @gpopsObjFirstBD;
    probinfo.eventgrd = @gpopsEventFirstBD;
    if probinfo.derivativelevel == 2;
      probinfo.conthes = @gpopsContSecondBD;
      probinfo.endphes = @gpopsEndpSecondBD;
    end
  end
end

% get auxdata data
if isfield(setup,'auxdata');
  probinfo.auxflag = true;
  probinfo.auxdata = setup.auxdata;
else
  probinfo.auxflag = false;
end

if strcmpi(setup.scales.method, 'none');
  probinfo.scaleflag = false;
else
  probinfo.scaleflag = true;
end

probinfo.numphase       = numphase;
probinfo.numstate       = numstate;
probinfo.numcontrol     = numcontrol;
probinfo.numpath        = numpath;
probinfo.numintegral    = numintegral;
probinfo.phaseduration  = phaseduration;
probinfo.numparameter   = numparameter;
probinfo.numeventgroup  = numeventgroup;
probinfo.numevent       = numevent;
probinfo.fixedtimeflag  = fixedtimeflag;
probinfo.fixedtimevalue = fixedtimevalue;